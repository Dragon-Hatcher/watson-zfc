Set theory is almost the simplest possible first order logical system. It
contains no formal terms and only a single binary predicate symbol: $\in$. 

syntax membership
    sentence ::= term " âˆˆ " term
end

The intended reading of $x \in y$ is that $y$ is a set of which $x$ is an element.
In our version of set theory, *all* objects are sets. Despite this simplicity,
we can encode essentially all of mathematics using set theory. We will find
ways to encode objects not traditionally thought of as sets using sets.

We have an intuitive notion of what a set is, but of course, we will need to
provide axioms to make this understanding rigorous.


## Axioms

The set of axioms we will be using for our set theory is called the 
Zermelo-Fraenkel axioms with Choice, abbreviated ZFC. There are other systems of
axioms we could use, but ZFC is a commonly accepted set.

You may be hoping that $\in$ will come with two axioms, an introduction and an
elimination rule. Sadly this is not the case.

We do get an elimination rule. It says that two sets are equal if they contain
exactly the same elements. This is traditionally known as extensionality. 

axiom zfc.extensionality :
    |- âˆ€a, âˆ€b, (âˆ€x, x âˆˆ a â†” x âˆˆ b) â†’ a = b
end

We will be presenting the axioms as unschematized statements in first-order
logic without using the iota operator. This is done to make clear the 
distinction between the axioms for which this can be done, and those for which 
it can't. We will state more natural forms of these axioms as theorems later.

Intuitively, a set is supposed to be a collection of all the objects with a
certain property. Therefore, we might naturally expect to have an introduction
rule similar to the following:

```
 axiom zfc.comprehension [p(_:term) : sentence] :
    |- âˆƒx, âˆ€y, (y âˆˆ x â†” p(y))
 end
```

However, such an axiom would be inconsistent. In particular, we would run into
Russell's paradox: the axiom allows us to construct the set $X = \{x ~|~ x \not\in x\}$
which consists of all sets which do not contain themselves. Then we ask if
$X \in X$. If it is then it should not be and if it isn't then it should be. We
have a contradiction. 

This leads us to the conclusion that not all properties can define sets. The
remainder of the axioms of ZFC essentially define restricted forms of our
idealized comprehension axiom which are believed not to lead to a contradiction.
This will leave us with various operations which we can use to define our sets.
In the end, almost all the sets we care about will be definable with these
operations and so we will be able to act much as if we did have unrestricted
comprehension.

The empty set axiom asserts the existence of a set with no elements.

axiom zfc.empty_set :
    |- âˆƒx, âˆ€y, Â¬y âˆˆ x 
end

For any two sets we can form the set containing exactly those two sets.

axiom zfc.pairing :
    |- âˆ€a, âˆ€b, âˆƒx, âˆ€y, y âˆˆ x â†” (y = a âˆ¨ y = b)
end

For any set we can take the union of all element in the set.

axiom zfc.union :
    |- âˆ€a, âˆƒx, âˆ€y, y âˆˆ x â†” (âˆƒz, y âˆˆ z âˆ§ z âˆˆ a)
end

For any set we can form the set of all subsets of the set (the powerset).

axiom zfc.powerset :
    |- âˆ€a, âˆƒx, âˆ€y, y âˆˆ x â†” (âˆ€z, z âˆˆ y â†’ z âˆˆ a)
end

There is a set containing the empty set with the property that for any $x$ in
the set, the set also contains $x \cup \{x\}$. Such a set is called an inductive
set and must be infinite. Without this axiom we would have no way to prove any
infinite sets exist.

axiom zfc.infinity :
    |- âˆƒx, (âˆƒy, y âˆˆ x âˆ§ âˆ€z, Â¬z âˆˆ y) 
         âˆ§ (âˆ€y, (y âˆˆ x â†’ (âˆƒz, (z âˆˆ x âˆ§ (âˆ€w, (w âˆˆ z â†” (w âˆˆ y âˆ¨ w = y)))))))
end

Then we get the two axiom schemas. These are statements about all sentences
which can't be stated using only quantifiers. The first says that for any set
we can take the subset of all elements with a particular property. This is 
quite similar to the rejected comprehension axiom, but this one doesn't lead to
contradictions (as far as we know). This is sometimes also called seperation or
restricted comprehension.

axiom zfc.specification [p(_:term) : sentence] :
    |- âˆ€a, âˆƒx, âˆ€y, y âˆˆ x â†” (y âˆˆ a âˆ§ p(y))
end

This axiom asserts that the image of any set under a function (implicitly 
defined by $p$) exists. This is surprisingly rarely required.

axiom zfc.replacement [p(_0:term, _1:term) : sentence] :
    |- âˆ€a, ((âˆ€x, x âˆˆ a â†’ âˆƒ!y, p(x, y)) â†’ (âˆƒx, âˆ€y, y âˆˆ x â†” (âˆƒz, z âˆˆ a âˆ§ p(z, y))))
end

The final axiom has a formal statement that is somewhat difficult to parse. But
the important point is that it guarantees that we do not get an infinite chain
of descending sets $x_0 \ni x_1 \ni x_2 \ni \dots$. In other words, all sets
are nested at a finite depth (despite the fact that some sets contain an 
infinite number of elements). 

axiom zfc.regularity :
    |- âˆ€a, (âˆƒx, x âˆˆ a) â†’ (âˆƒy, y âˆˆ a âˆ§ Â¬âˆƒz, (z âˆˆ y âˆ§ z âˆˆ a))
end

The final axiom is the famed Axiom of Choice. It is the C in ZFC. However it has 
a much longer first order statement and it is generally considered more polite 
to be clear when one is using it. So we will postpone adding it until it becomes 
necessary.


## Set Operations

The fundamental operation over sets is forming the set of all elements with a
certain property. We discussed previously that this set does not always exist,
however the iota operator allows us to define notation for it which will have
the expected properties if it does exist.

notation comprehension
    term ::= "{" x:@binding(term) " | " sentence(x) "}"
end

definition
    {x | p(x)} := â„©y, âˆ€x, x âˆˆ y â†” p(x)
end

We want to prove that if the set $\{x ~|~ p(x)\}$ exists, then the notation we 
have given for it will refer to that step. We need to invoke the iota axiom
from the previous chapter.

theorem uncomp.def [p(_:term) : sentence] : (âˆƒx, âˆ€y, y âˆˆ x â†” p(y))
    |- âˆ€y, y âˆˆ {x | p(x)} â†” p(y) 
proof
    -- this property is essentially the definition of {x | p(x)} so we just
    -- need to extract it using iota.unique. to do this we need that
    -- the set is unique.
    suffices âˆƒ!x, âˆ€y, y âˆˆ x â†” p(y) by iota.unique [âˆ€y, y âˆˆ _ â†” p(y)];

    -- we can unwrap the definition of âˆƒ!. this step is by definition.
    suffices (âˆƒx, âˆ€y, y âˆˆ x â†” p(y)) âˆ§ (âˆƒ*x, âˆ€y, y âˆˆ x â†” p(y));

    -- we already have the lhs as a hypothesis.
    suffices âˆƒ*x, âˆ€y, y âˆˆ x â†” p(y) by and.intro [âˆƒx, âˆ€y, y âˆˆ x â†” p(y)] [âˆƒ*x, âˆ€y, y âˆˆ x â†” p(y)];

    -- now we unwrap the definition of âˆƒ*.
    suffices âˆ€a, âˆ€b, ((âˆ€y, y âˆˆ a â†” p(y)) âˆ§ (âˆ€y, y âˆˆ b â†” p(y))) â†’ a = b;

    -- let's extract all the pieces of this definition.
    arbitrary a;
    arbitrary b;
    assume (âˆ€y, y âˆˆ a â†” p(y)) âˆ§ (âˆ€y, y âˆˆ b â†” p(y));
    thus âˆ€y, y âˆˆ a â†” p(y) by and.elim_left  [âˆ€y, y âˆˆ a â†” p(y)] [âˆ€y, y âˆˆ b â†” p(y)];
    thus âˆ€y, y âˆˆ b â†” p(y) by and.elim_right [âˆ€y, y âˆˆ a â†” p(y)] [âˆ€y, y âˆˆ b â†” p(y)];

    -- now we can prove the equality using extensionality.
    suffices âˆ€x, x âˆˆ a â†” x âˆˆ b as
        follows âˆ€a, âˆ€b, ((âˆ€x, x âˆˆ a â†” x âˆˆ b) â†’ a = b) by zfc.extensionality;
        thus âˆ€b, ((âˆ€x, x âˆˆ a â†” x âˆˆ b) â†’ a = b) specializing âˆ€a, âˆ€b, ((âˆ€x, x âˆˆ a â†” x âˆˆ b) â†’ a = b);
        thus (âˆ€x, x âˆˆ a â†” x âˆˆ b) â†’ a = b       specializing âˆ€b, ((âˆ€x, x âˆˆ a â†” x âˆˆ b) â†’ a = b);
        thus a = b by modus_ponens [âˆ€x, x âˆˆ a â†” x âˆˆ b] [a = b];
    ;

    arbitrary x;

    -- We can use the transitivity of â†” to finish the proof.
    follows x âˆˆ a â†” p(x) specializing âˆ€y, y âˆˆ a â†” p(y);
    follows x âˆˆ b â†” p(x) specializing âˆ€y, y âˆˆ b â†” p(y);
    thus p(x) â†” x âˆˆ b  by iff.symm [x âˆˆ b] [p(x)];
    thus x âˆˆ a â†” x âˆˆ b by iff.trans [x âˆˆ a] [p(x)] [x âˆˆ b];
qed

Sorry, was that painful to read? It was painful to write. That proof wasn't
actually very complicated but it was 40 lines long anyway. This is not 
sustainable. Lucky we have something to help. [Vampire](https://vprover.github.io/)
is an _automated theorem prover_. It will find proofs of mathematical facts
automatically. We can make a new tactic that send the current known facts and
goal to Vampire to have it generate a proof. This proof is then translated
for Watson to understand. This is a very complex, but also very powerful tactic
which eliminates the need for tedious manipulations.

tactic tactic.vampire
    tactic ::= @kw"vampire"
end

We have also enhanced our pre-existing tactics with the power of Vampire. For
example, `contradiction` will now use Vampire to search for a contradiction and
`by` will now employ Vampire to prove the goal using the theorem. If we want to 
inform Vampire of a theorem it would find useful we can also use the `recall`
 tactic which will add the named theorem to our list of known facts, making it
useable by Vampire.

tactic tactic.recall
    tactic ::= @kw"recall" thm:@name ";" next:tactic
end

Returning to mathematics, we can use the unrestricted comprehension syntax to 
define our first concrete set, the empty set.

notation empty_set
    term ::= "âˆ…"
end

definition
    âˆ… := {x | âŠ¥}
end

The empty set axiom tells us that this set actually exists.

theorem empty_set.def :
    |- âˆ€x, Â¬x âˆˆ âˆ…
proof
    -- expand the definition of âˆ…
    suffices âˆ€x, Â¬x âˆˆ {x | âŠ¥};
    -- existence from the axiom
    follows âˆƒx, âˆ€y, Â¬y âˆˆ x        by zfc.empty_set;
    thus    âˆƒx, âˆ€y, (y âˆˆ x â†” âŠ¥)   as vampire;     
    -- and then set comprehension is always unique
    thus    âˆ€y, (y âˆˆ {x | âŠ¥} â†” âŠ¥) by uncomp.def [âŠ¥];
    thus    âˆ€y, Â¬y âˆˆ {x | âŠ¥}      as vampire;
qed

We can develop the pair set in an essentially identical way.

notation pair
    term ::= "{" term ", " term "}"
end

definition 
    {a, b} := {x | x = a âˆ¨ x = b}
end

This time it is the pairing axiom that tells us that this set exists.

theorem pair.def [a b : term] :
    |- âˆ€x, x âˆˆ {a, b} â†” (x = a âˆ¨ x = b)
proof
    suffices âˆ€x, x âˆˆ {y | y = a âˆ¨ y = b} â†” (x = a âˆ¨ x = b);
    
    follows âˆƒc, âˆ€x, x âˆˆ c â†” (x = a âˆ¨ x = b) as recall zfc.pairing; vampire;
    thus    âˆ€x, x âˆˆ {y | y = a âˆ¨ y = b} â†” (x = a âˆ¨ x = b) by uncomp.def [_ = a âˆ¨ _ = b];
qed

We can define the singleton set as the pair of the same element twice. We could
define it as simply $\{a\} = \{x ~|~ x = a\}$ but how would we prove this set
exists? We would have to appeal to the pairing axiom anyway.

notation singleton
    term ::= "{" term "}"
end

definition
    {a} := {a, a}
end

theorem singleton.def [a : term] :
    |- âˆ€x, x âˆˆ {a} â†” x = a
proof
    -- expand the definition of {a}
    suffices âˆ€x, x âˆˆ {a, a} â†” x = a;
    -- and then Vampire easily finishes the job from the definition of {a, a}
    recall pair.def; vampire
qed

We can return to defining new sets with the union of a set.

notation big_union
    term ::= "â‹ƒ" term
end

definition
    â‹ƒa := {x | âˆƒy, x âˆˆ y âˆ§ y âˆˆ a}
end

Once more the existence of this set is guaranteed by the union axiom of ZFC.

theorem big_union.def [a : term] :
    |- âˆ€x, x âˆˆ â‹ƒa â†” (âˆƒy, x âˆˆ y âˆ§ y âˆˆ a)
proof
    suffices âˆ€x, x âˆˆ {x | âˆƒy, x âˆˆ y âˆ§ y âˆˆ a} â†” (âˆƒy, x âˆˆ y âˆ§ y âˆˆ a);
    recall zfc.union;
    follows âˆƒx, âˆ€y, y âˆˆ x â†” (âˆƒz, y âˆˆ z âˆ§ z âˆˆ a) as vampire;
    follows âˆ€x, x âˆˆ {x | âˆƒy, x âˆˆ y âˆ§ y âˆˆ a} â†” (âˆƒy, x âˆˆ y âˆ§ y âˆˆ a) by uncomp.def [âˆƒy, _ âˆˆ y âˆ§ y âˆˆ a];
qed

We can define the regular union using the pair and the big union. Once again,
although we could define this directly using unrestricted comprehension, it is
easier to do it this way to avoid repeated proofs of existence.

notation union
    term ::= term " âˆª " term
end

definition
    a âˆª b := â‹ƒ{a, b}
end

The definition of the union can be easily proved from the definitions of the
big union and the pair.

theorem union.def [a b : term] :
    |- âˆ€x, x âˆˆ a âˆª b â†” (x âˆˆ a âˆ¨ x âˆˆ b)
proof
    suffices âˆ€x, x âˆˆ â‹ƒ{a, b} â†” (x âˆˆ a âˆ¨ x âˆˆ b);
    follows  âˆ€x, x âˆˆ â‹ƒ{a, b} â†” âˆƒy, x âˆˆ y âˆ§ y âˆˆ {a, b} as recall big_union.def; vampire;
    follows  âˆ€y, y âˆˆ {a, b} â†” (y = a âˆ¨ y = b) as recall pair.def; vampire;
    vampire
qed

We wish next to construct the powerset. For this we will need the notation of
subsets.

notation subset
    sentence ::= term " âŠ† " term
end

definition
    a âŠ† b := âˆ€x, x âˆˆ a â†’ x âˆˆ b
end

We can also have the notion of a strict subsets.

notation strict_subset
    sentence ::= term " âŠ‚ " term
end

definition
    a âŠ‚ b := a âŠ† b âˆ§ Â¬a = b
end

The empty set is a subset of any set.

theorem empty.sub [a : term] :
    |- âˆ… âŠ† a
proof
    follows âˆ€x, Â¬x âˆˆ âˆ…        by empty_set.def;
    thus    âˆ€x, x âˆˆ âˆ… â†’ x âˆˆ a as vampire;
qed

We will define the powerset as the set of all subsets of a set. 

notation term.with_term
    term ::= @name "(" term ")"
end

definition
    ğ’«(a) := {x | x âŠ† a}
end

The existence of this set is provided by one of the ZFC axioms in the same
manner as before.

theorem powset.def [a : term] :
    |- âˆ€x, x âˆˆ ğ’«(a) â†” x âŠ† a
proof
    suffices âˆ€x, x âˆˆ {y | y âŠ† a} â†” x âŠ† a;
    follows  âˆƒb, âˆ€x, x âˆˆ b â†” x âŠ† a as
        -- TODO: vampire should be able to handle subset without this manual
        -- expansion.
        suffices âˆƒb, âˆ€x, x âˆˆ b â†” (âˆ€y, y âˆˆ x â†’ y âˆˆ a);
        recall zfc.powerset;
        vampire
    ;
    thus âˆ€x, x âˆˆ {y | y âŠ† a} â†” x âŠ† a by uncomp.def [_ âŠ† a];
qed

In contrast to unrestricted comprehensions, which are not always sets, a
comprehension which is limited to be a subset of another set always exists. This
is guaranteed by the specification axiom.

notation restricted_comprehension
    term ::= "{" x:@binding(term) " âˆˆ " term " | " sentence(x) "}"
end

definition
    {x âˆˆ X | p(x)} := {x | x âˆˆ X âˆ§ p(x)}
end

This proof follows from the specification axiom.

theorem comp.def [p(_:term) : sentence] [X : term] :
    |- âˆ€y, y âˆˆ {x âˆˆ X | p(x)} â†” (y âˆˆ X âˆ§ p(y))
proof
    suffices âˆ€y, y âˆˆ {x | x âˆˆ X âˆ§ p(x)} â†” (y âˆˆ X âˆ§ p(y));
    hence âˆ€a, âˆƒx, âˆ€y, y âˆˆ x â†” (y âˆˆ a âˆ§ p(y)) by zfc.specification [p(_)];
    follows âˆƒx, âˆ€y, y âˆˆ x â†” (y âˆˆ X âˆ§ p(y)) as vampire;
    thus âˆ€y, y âˆˆ {x | x âˆˆ X âˆ§ p(x)} â†” (y âˆˆ X âˆ§ p(y)) by uncomp.def [_ âˆˆ X âˆ§ p(_)];
qed

It easily follows from this definition that a restricted comprehension is
always a subset of the original set.

theorem comp.sub [p(_:term) : sentence] [X : term] :
    |- {x âˆˆ X | p(x)} âŠ† X
proof
    follows âˆ€y, y âˆˆ {x âˆˆ X | p(x)} â†” (y âˆˆ X âˆ§ p(y)) by comp.def [p(_)] [X];
    thus    âˆ€y, y âˆˆ {x âˆˆ X | p(x)} â†’ y âˆˆ X          as vampire;
qed

An ordered pair (a, b) is a set composed of a singleton {a} and a pair {a, b}. We can use ordered pairs to enforce certain structure on sets.
notation ordered_pair
    term ::= "(" term ", " term ")"
end

definition
    (a, b) := {{a}, {a, b}}
end

The proof follows from the pairing axiom and the definition of the ordered pair.

theorem ordered_pair.def [a b : term] :
    |- âˆ€x, x âˆˆ (a, b) â†” (x = {a} âˆ¨ x = {a, b})
proof
    suffices âˆ€x, x âˆˆ {{a}, {a, b}} â†” (x = {a} âˆ¨ x = {a, b});
    recall zfc.pairing;
    follows âˆƒc, âˆ€x, x âˆˆ c â†” (x = {a} âˆ¨ x = {a, b}) as vampire;
    thus âˆ€x, x âˆˆ {{a}, {a, b}} â†” (x = {a} âˆ¨ x = {a, b}) by uncomp.def [_ = {a} âˆ¨ _ = {a, b}];
qed