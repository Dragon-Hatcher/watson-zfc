Set theory is almost the simplest possible first order logical system. It
contains no formal terms and only a single binary predicate symbol: $\in$. 

syntax in
    sentence ::= term " âˆˆ " term
end

notation non_in
    sentence ::= term " âˆ‰ " term
end

definition
    a âˆ‰ b := Â¬a âˆˆ b
end

The intended reading of $x \in y$ is that $y$ is a set of which $x$ is an element.
In our version of set theory, *all* objects are sets. Despite this simplicity,
we can encode essentially all of mathematics using set theory. We will find
ways to encode objects not traditionally thought of as sets using sets.

We have an intuitive notion of what a set is, but of course, we will need to
provide axioms to make this understanding rigorous.


## Axioms

The set of axioms we will be using for our set theory is called the 
Zermelo-Fraenkel axioms with Choice, abbreviated ZFC. There are other systems of
axioms we could use, but ZFC is a commonly accepted set.

You may be hoping that $\in$ will come with two axioms, an introduction and an
elimination rule. Sadly this is not the case.

We do get an elimination rule. It says that two sets are equal if they contain
exactly the same elements. This is traditionally known as extensionality. 

axiom zfc.extensionality :
    |- âˆ€a, âˆ€b, (âˆ€x, x âˆˆ a â†” x âˆˆ b) â†’ a = b
end

We will be presenting the axioms as unschematized statements in first-order
logic without using the iota operator. This is done to make clear the 
distinction between the axioms for which this can be done, and those for which 
it can't. We will state more natural forms of these axioms as theorems later.

Intuitively, a set is supposed to be a collection of all the objects with a
certain property. Therefore, we might naturally expect to have an introduction
rule similar to the following:

```
 axiom zfc.comprehension [p(_:term) : sentence] :
    |- âˆƒx, âˆ€y, (y âˆˆ x â†” p(y))
 end
```

However, such an axiom would be inconsistent. In particular, we would run into
Russell's paradox: the axiom allows us to construct the set $X = \{x ~|~ x \not\in x\}$
which consists of all sets which do not contain themselves. Then we ask if
$X \in X$. If it is then it should not be and if it isn't then it should be. We
have a contradiction. 

This leads us to the conclusion that not all properties can define sets. The
remainder of the axioms of ZFC essentially define restricted forms of our
idealized comprehension axiom which are believed not to lead to a contradiction.
This will leave us with various operations which we can use to define our sets.
In the end, almost all the sets we care about will be definable with these
operations and so we will be able to act much as if we did have unrestricted
comprehension.

The empty set axiom asserts the existence of a set with no elements.

axiom zfc.empty_set :
    |- âˆƒx, âˆ€y, y âˆ‰ x 
end

For any two sets we can form the set containing exactly those two sets.

axiom zfc.pairing :
    |- âˆ€a, âˆ€b, âˆƒx, âˆ€y, y âˆˆ x â†” (y = a âˆ¨ y = b)
end

For any set we can take the union of all elements in the set.

axiom zfc.union :
    |- âˆ€a, âˆƒx, âˆ€y, y âˆˆ x â†” (âˆƒz, y âˆˆ z âˆ§ z âˆˆ a)
end

For any set we can form the set of all subsets of the set (the powerset).

axiom zfc.powerset :
    |- âˆ€a, âˆƒx, âˆ€y, y âˆˆ x â†” (âˆ€z, z âˆˆ y â†’ z âˆˆ a)
end

There is a set containing the empty set with the property that for any $x$ in
the set, the set also contains $x \cup \{x\}$. Such a set is called an inductive
set and must be infinite. Without this axiom we would have no way to prove any
infinite sets exist.

axiom zfc.infinity :
    |- âˆƒx, (âˆƒy, y âˆˆ x âˆ§ âˆ€z, z âˆ‰ y) 
         âˆ§ (âˆ€y, (y âˆˆ x â†’ (âˆƒz, (z âˆˆ x âˆ§ (âˆ€w, (w âˆˆ z â†” (w âˆˆ y âˆ¨ w = y)))))))
end

Then we get the two axiom schemas. These are statements about all sentences
which can't be stated using only quantifiers. The first says that for any set
we can take the subset of all elements with a particular property. This is 
quite similar to the rejected comprehension axiom, but this one doesn't lead to
contradictions (as far as we know). This is sometimes also called separation or
restricted comprehension.

axiom zfc.specification [p(_:term) : sentence] :
    |- âˆ€a, âˆƒx, âˆ€y, y âˆˆ x â†” (y âˆˆ a âˆ§ p(y))
end

This axiom asserts that the image of any set under a function (implicitly 
defined by $p$) exists. This is surprisingly rarely required.

axiom zfc.replacement [p(_0:term, _1:term) : sentence] :
    |- âˆ€a, ((âˆ€x, x âˆˆ a â†’ âˆƒ!y, p(x, y)) â†’ (âˆƒx, âˆ€y, y âˆˆ x â†” (âˆƒz, z âˆˆ a âˆ§ p(z, y))))
end

The final axiom has a formal statement that is somewhat difficult to parse. But
the important point is that it guarantees that we do not get an infinite chain
of descending sets $x_0 \ni x_1 \ni x_2 \ni \dots$. In other words, all sets
are nested at a finite depth (despite the fact that some sets contain an 
infinite number of elements). 

axiom zfc.regularity :
    |- âˆ€a, (âˆƒx, x âˆˆ a) â†’ (âˆƒy, y âˆˆ a âˆ§ Â¬âˆƒz, (z âˆˆ y âˆ§ z âˆˆ a))
end

The final axiom is the famed Axiom of Choice. It is the C in ZFC. However it has 
a much longer first order statement and it is generally considered more polite 
to be clear when one is using it. So we will postpone adding it until it becomes 
necessary.


## Set Operations

The fundamental operation over sets is forming the set of all elements with a
certain property. We discussed previously that this set does not always exist,
however the iota operator allows us to define notation for it which will have
the expected properties if it does exist.

notation comprehension
    term ::= "{" x:@binding(term) " | " sentence(x) "}"
end

definition
    {x | p(x)} := â„©y, âˆ€x, x âˆˆ y â†” p(x)
end

We want to prove that if the set $\{x ~|~ p(x)\}$ exists, then the notation we 
have given for it will refer to that set. We need to invoke the iota axiom
from the previous chapter.

theorem uncomp.def [p(_:term) : sentence] : (âˆƒx, âˆ€y, y âˆˆ x â†” p(y))
    |- âˆ€y, y âˆˆ {x | p(x)} â†” p(y) 
proof
    -- this property is essentially the definition of {x | p(x)} so we just
    -- need to extract it using iota.unique. to do this we need that
    -- the set is unique.
    suffices âˆƒ!x, âˆ€y, y âˆˆ x â†” p(y) by iota.unique [âˆ€y, y âˆˆ _ â†” p(y)];

    -- we can unwrap the definition of âˆƒ!. this step is by definition.
    suffices (âˆƒx, âˆ€y, y âˆˆ x â†” p(y)) âˆ§ (âˆƒ*x, âˆ€y, y âˆˆ x â†” p(y));

    -- we already have the lhs as a hypothesis.
    suffices âˆƒ*x, âˆ€y, y âˆˆ x â†” p(y) by and.intro [âˆƒx, âˆ€y, y âˆˆ x â†” p(y)] [âˆƒ*x, âˆ€y, y âˆˆ x â†” p(y)];

    -- now we unwrap the definition of âˆƒ*.
    suffices âˆ€a, âˆ€b, ((âˆ€y, y âˆˆ a â†” p(y)) âˆ§ (âˆ€y, y âˆˆ b â†” p(y))) â†’ a = b;

    -- let's extract all the pieces of this definition.
    arbitrary a;
    arbitrary b;
    assume (âˆ€y, y âˆˆ a â†” p(y)) âˆ§ (âˆ€y, y âˆˆ b â†” p(y));
    thus âˆ€y, y âˆˆ a â†” p(y) by and.elim_left  [âˆ€y, y âˆˆ a â†” p(y)] [âˆ€y, y âˆˆ b â†” p(y)];
    thus âˆ€y, y âˆˆ b â†” p(y) by and.elim_right [âˆ€y, y âˆˆ a â†” p(y)] [âˆ€y, y âˆˆ b â†” p(y)];

    -- now we can prove the equality using extensionality.
    suffices âˆ€x, x âˆˆ a â†” x âˆˆ b as
        follows âˆ€a, âˆ€b, ((âˆ€x, x âˆˆ a â†” x âˆˆ b) â†’ a = b) by zfc.extensionality;
        thus âˆ€b, ((âˆ€x, x âˆˆ a â†” x âˆˆ b) â†’ a = b) specializing âˆ€a, âˆ€b, ((âˆ€x, x âˆˆ a â†” x âˆˆ b) â†’ a = b);
        thus (âˆ€x, x âˆˆ a â†” x âˆˆ b) â†’ a = b       specializing âˆ€b, ((âˆ€x, x âˆˆ a â†” x âˆˆ b) â†’ a = b);
        thus a = b by modus_ponens [âˆ€x, x âˆˆ a â†” x âˆˆ b] [a = b];
    ;

    arbitrary x;

    -- We can use the transitivity of â†” to finish the proof.
    follows x âˆˆ a â†” p(x) specializing âˆ€y, y âˆˆ a â†” p(y);
    follows x âˆˆ b â†” p(x) specializing âˆ€y, y âˆˆ b â†” p(y);
    thus p(x) â†” x âˆˆ b  by iff.symm [x âˆˆ b] [p(x)];
    thus x âˆˆ a â†” x âˆˆ b by iff.trans [x âˆˆ a] [p(x)] [x âˆˆ b];
qed

Sorry, was that painful to read? It was painful to write. That proof wasn't
actually very complicated but it was 40 lines long anyway. This is not 
sustainable. Lucky we have something to help. [Vampire](https://vprover.github.io/)
is an _automated theorem prover_. It will find proofs of mathematical facts
automatically. We can make a new tactic that sends the current known facts and
goal to Vampire to have it generate a proof. This proof is then translated
for Watson to understand. This is a very complex but also very powerful tactic
which eliminates the need for tedious manipulations.

tactic tactic.vampire
    tactic ::= @kw"vampire"
end

tactic justification.logically
    justification ::= @kw"logically"
end

-- TODO: explain
tactic tactic.done
    tactic ::= @kw"done" just:justification
end


We have also enhanced our pre-existing tactics with the power of Vampire. For
example, `contradiction` will now use Vampire to search for a contradiction and
`by` will now employ Vampire to prove the goal using the theorem. If we want to 
inform Vampire of a theorem that it would find useful we can also use the `recall`
 tactic which will add the named theorem to our list of known facts, making it
usable by Vampire.

tactic tactic.recall
    tactic ::= @kw"recall" thm:@name ";" next:tactic
end

### The Subset Relation

The other fundamental relationship between sets, besides equality, is the
subset relation.

notation subset
    sentence ::= term " âŠ† " term
end

definition
    a âŠ† b := âˆ€x, x âˆˆ a â†’ x âˆˆ b
end

We can also have the notion of a strict subset.

notation strict_subset
    sentence ::= term " âŠ‚ " term
end

definition
    a âŠ‚ b := a âŠ† b âˆ§ a â‰  b
end

theorem sub.def [a b : term] :
    |- a âŠ† b â†” âˆ€x, x âˆˆ a â†’ x âˆˆ b
proof
    done by iff.refl [a âŠ† b]
qed

theorem ssub.def [a b : term] :
    |- a âŠ‚ b â†” (a âŠ† b âˆ§ a â‰  b)
proof
    done by iff.refl [a âŠ‚ b]
qed

### Bounded Quantifiers

When defining the subset relation we wrote $\forall x, x \in a \to x \in b$. The
$x \in a \to$ component makes the quantifier only meaningful for elements of the
set $a$. This is a very common pattern so we will define shorthand notation for
it. 

notation forall.bounded
    sentence ::= "âˆ€" x:@binding(term) " âˆˆ " term ", " sentence(x)
end

definition
    âˆ€x âˆˆ X, p(x) := âˆ€x, x âˆˆ X â†’ p(x)
end

Note that for the existential quantifier we use $\land$ instead of $\to$
because we are looking for an element that is both in the set and satisfies
the property.

notation exists.bounded
    sentence ::= "âˆƒ" x:@binding(term) " âˆˆ " term ", " sentence(x)
end

definition
    âˆƒx âˆˆ X, p(x) := âˆƒx, x âˆˆ X âˆ§ p(x)
end

### The Empty Set

Returning to mathematics, we can use the unrestricted comprehension syntax to 
define our first concrete set, the empty set.

notation empty_set
    term ::= "âˆ…"
end

definition
    âˆ… := {x | âŠ¥}
end

The empty set axiom tells us that this set actually exists.

theorem empty.def :
    |- âˆ€x, x âˆ‰ âˆ…
proof
    -- expand the definition of âˆ…
    suffices âˆ€x, x âˆ‰ {x | âŠ¥};
    -- existence from the axiom
    follows âˆƒx, âˆ€y,  y âˆ‰ x        by zfc.empty_set;
    thus    âˆƒx, âˆ€y, (y âˆˆ x â†” âŠ¥)   logically;     
    -- and then set comprehension is always unique
    thus    âˆ€y, (y âˆˆ {x | âŠ¥} â†” âŠ¥) by uncomp.def [âŠ¥];
    thus    âˆ€y,  y âˆ‰ {x | âŠ¥}      logically;
qed

We can also characterize a non-empty set as one containing an element.

theorem nonempty.has_element [a : term] :
    |- a â‰  âˆ… â†” âˆƒx, x âˆˆ a
proof
    follows âˆ€x, x âˆ‰ âˆ…          by empty.def;
    follows a = âˆ… â†”  âˆ€x, x âˆ‰ a by zfc.extensionality; 
    thus    a â‰  âˆ… â†” Â¬âˆ€x, x âˆ‰ a logically;
    thus    a â‰  âˆ… â†”  âˆƒx, x âˆˆ a logically;
qed

The empty set is a subset of any set.

theorem empty.sub [a : term] :
    |- âˆ… âŠ† a
proof
    follows âˆ€x, x âˆ‰ âˆ…        by empty.def;
    thus    âˆ€x, x âˆˆ âˆ… â†’ x âˆˆ a logically;
qed

### The Unordered Pair

We can develop the pair set in an essentially identical way.

notation pair
    term ::= "{" term ", " term "}"
end

definition 
    {a, b} := {x | x = a âˆ¨ x = b}
end

This time it is the pairing axiom that tells us that this set exists.

theorem pair.def [a b : term] :
    |- âˆ€x, x âˆˆ {a, b} â†” (x = a âˆ¨ x = b)
proof
    suffices âˆ€x, x âˆˆ {y | y = a âˆ¨ y = b} â†” (x = a âˆ¨ x = b);
    follows âˆƒc, âˆ€x, x âˆˆ c â†” (x = a âˆ¨ x = b)               by zfc.pairing;
    thus    âˆ€x, x âˆˆ {y | y = a âˆ¨ y = b} â†” (x = a âˆ¨ x = b) by uncomp.def [_ = a âˆ¨ _ = b];
qed

The unordered pair is unordered. That is, it is symmetric.

theorem pair.symm [a b : term] :
    |- {a, b} = {b, a}
proof
    todo
qed

The unordered pair being a subset is equivalent to both elements of the pair
being members of the set.

theorem pair.sub [a b A : term] :
    |- (a âˆˆ A âˆ§ b âˆˆ A) â†” {a, b} âŠ† A
proof
    recall sub.def;
    done by pair.def
qed

### The Singleton Set

We can define the singleton set as the pair of the same element twice. We could
define it as simply $\{a\} = \{x ~|~ x = a\}$ but how would we prove this set
exists? We would have to appeal to the pairing axiom anyway.

notation singleton
    term ::= "{" term "}"
end

definition
    {a} := {a, a}
end

theorem singleton.def [a : term] :
    |- âˆ€x, x âˆˆ {a} â†” x = a
proof
    -- expand the definition of {a}
    suffices âˆ€x, x âˆˆ {a, a} â†” x = a;
    -- and then Vampire easily finishes the job from the definition of {a, a}
    thus âˆ€x, x âˆˆ {a, a} â†” x = a by pair.def;
qed

An element being in a set is equivalent to the singleton set being a subset.

theorem singleton.sub [a A : term] :
    |- a âˆˆ A â†” {a} âŠ† A
proof
    follows a âˆˆ A â†’ (âˆ€x, x âˆˆ {a} â†’ x âˆˆ A) by singleton.def;
    follows (âˆ€x, x âˆˆ {a} â†’ x âˆˆ A) â†’ a âˆˆ A by singleton.def;
    done by sub.def
qed

### Restricted Comprehension

In contrast to unrestricted comprehensions, which are not always sets, a
comprehension which is limited to be a subset of another set always exists. This
is guaranteed by the specification axiom.

notation restricted_comprehension
    term ::= "{" x:@binding(term) " âˆˆ " term " | " sentence(x) "}"
end

definition
    {x âˆˆ X | p(x)} := {x | x âˆˆ X âˆ§ p(x)}
end

This proof follows from the specification axiom.

theorem comp.def [p(_:term) : sentence] [X : term] :
    |- âˆ€y, y âˆˆ {x âˆˆ X | p(x)} â†” (y âˆˆ X âˆ§ p(y))
proof
    suffices âˆ€y, y âˆˆ {x | x âˆˆ X âˆ§ p(x)} â†” (y âˆˆ X âˆ§ p(y));
    hence âˆ€a, âˆƒx, âˆ€y, y âˆˆ x â†” (y âˆˆ a âˆ§ p(y)) by zfc.specification [p(_)];
    follows âˆƒx, âˆ€y, y âˆˆ x â†” (y âˆˆ X âˆ§ p(y))   logically;
    thus âˆ€y, y âˆˆ {x | x âˆˆ X âˆ§ p(x)} â†” (y âˆˆ X âˆ§ p(y)) by uncomp.def [_ âˆˆ X âˆ§ p(_)];
qed

It easily follows from this definition that a restricted comprehension is
always a subset of the original set.

theorem comp.sub [p(_:term) : sentence] [X : term] :
    |- {x âˆˆ X | p(x)} âŠ† X
proof
    follows âˆ€y, y âˆˆ {x âˆˆ X | p(x)} â†” (y âˆˆ X âˆ§ p(y)) by comp.def [p(_)] [X];
    thus    âˆ€y, y âˆˆ {x âˆˆ X | p(x)} â†’ y âˆˆ X          logically;
qed

### Unions

We can return to defining new sets with the union of a set.

notation big_union
    term ::= "â‹ƒ" term
end

definition
    â‹ƒa := {x | âˆƒy, x âˆˆ y âˆ§ y âˆˆ a}
end

Once more the existence of this set is guaranteed by the union axiom of ZFC.

theorem big_union.def [a : term] :
    |- âˆ€x, x âˆˆ â‹ƒa â†” (âˆƒy, x âˆˆ y âˆ§ y âˆˆ a)
proof
    suffices âˆ€x, x âˆˆ {x | âˆƒy, x âˆˆ y âˆ§ y âˆˆ a} â†” (âˆƒy, x âˆˆ y âˆ§ y âˆˆ a);
    follows âˆƒx, âˆ€y, y âˆˆ x â†” (âˆƒz, y âˆˆ z âˆ§ z âˆˆ a) by zfc.union;
    follows âˆ€x, x âˆˆ {x | âˆƒy, x âˆˆ y âˆ§ y âˆˆ a} â†” (âˆƒy, x âˆˆ y âˆ§ y âˆˆ a) by uncomp.def [âˆƒy, _ âˆˆ y âˆ§ y âˆˆ a];
qed

Any element of a set is a subset of the union of that set.

theorem big_union.super [a b : term] : (a âˆˆ b)
    |- a âŠ† â‹ƒb
proof
    follows âˆ€x, (âˆƒy, x âˆˆ y âˆ§ y âˆˆ b) â†” x âˆˆ â‹ƒb by big_union.def;
    thus    âˆ€x,      x âˆˆ a          â†’ x âˆˆ â‹ƒb logically;
qed

We can define the regular union using the pair and the big union. Once again,
although we could define this directly using unrestricted comprehension, it is
easier to do it this way to avoid repeated proofs of existence.

notation union
    term ::= term " âˆª " term
end

definition
    a âˆª b := â‹ƒ{a, b}
end

The definition of the union can be easily proved from the definitions of the
big union and the pair.

theorem union.def [a b : term] :
    |- âˆ€x, x âˆˆ a âˆª b â†” (x âˆˆ a âˆ¨ x âˆˆ b)
proof
    suffices âˆ€x, x âˆˆ â‹ƒ{a, b} â†” (x âˆˆ a âˆ¨ x âˆˆ b);
    follows  âˆ€x, x âˆˆ â‹ƒ{a, b} â†” âˆƒy, x âˆˆ y âˆ§ y âˆˆ {a, b} by big_union.def;
    follows  âˆ€y, y âˆˆ  {a, b} â†” (y = a âˆ¨ y = b)        by pair.def;
    done logically
qed

The union operator is also symmetric. This follows either from the fact that
the unordered pair is symmetric, or just the symmetry of or itself.

theorem union.symm [a b : term] :
    |- a âˆª b = b âˆª a
proof
    follows âˆ€x, x âˆˆ a âˆª b â†” (x âˆˆ a âˆ¨ x âˆˆ b) by union.def;
    follows âˆ€x, x âˆˆ b âˆª a â†” (x âˆˆ a âˆ¨ x âˆˆ b) by union.def;
    thus a âˆª b = b âˆª a                      by zfc.extensionality;
qed

The union is also associative. This follows from the associativity of or.

theorem union.assoc [a b c : term] :
    |- a âˆª (b âˆª c) = (a âˆª b) âˆª c
proof
    follows âˆ€x, x âˆˆ a âˆª (b âˆª c) â†” (x âˆˆ a âˆ¨ (x âˆˆ b âˆ¨ x âˆˆ c)) by union.def;
    follows âˆ€x, x âˆˆ (a âˆª b) âˆª c â†” ((x âˆˆ a âˆ¨ x âˆˆ b) âˆ¨ x âˆˆ c) by union.def;
    thus a âˆª (b âˆª c) = (a âˆª b) âˆª c                          by zfc.extensionality;
qed

Either set in the union is a subset of the union as a whole. These facts are
really just simplifications of the defining fact.

theorem union.left_sub [a b : term] :
    |- a âŠ† a âˆª b
proof
    follows âˆ€x, (x âˆˆ a âˆ¨ x âˆˆ b) â†” x âˆˆ a âˆª b by union.def;
    thus    âˆ€x,  x âˆˆ a          â†’ x âˆˆ a âˆª b logically;
qed

theorem union.right_sub [a b : term] :
    |- b âŠ† a âˆª b
proof
    follows âˆ€x, (x âˆˆ a âˆ¨ x âˆˆ b) â†” x âˆˆ a âˆª b by union.def;
    thus    âˆ€x,          x âˆˆ b  â†’ x âˆˆ a âˆª b logically;
qed

### Intersections

Instead of defining the big intersection with an unrestricted comprehension as
we did for the big union, we will define it as a subset of the union. This
makes it easier to prove existence.

notation big_inter
    term ::= "â‹‚" term
end

definition
    â‹‚a := {x âˆˆ â‹ƒa | âˆ€y, y âˆˆ a â†’ x âˆˆ y}
end

This definition implies that the intersection of the empty set is the empty set.
However, based on the defining property of the intersection, the intersection of
the empty set should be the proper class of all sets, which isn't a set. So we
restrict the definition theorem to only applying to non-empty sets.

theorem big_inter.def [a : term] : (a â‰  âˆ…)
    |- âˆ€x, x âˆˆ â‹‚a â†” (âˆ€y, y âˆˆ a â†’ x âˆˆ y)
proof
    arbitrary x;

    follows âˆ€x', x' âˆˆ â‹‚a â†” (x' âˆˆ â‹ƒa âˆ§ (âˆ€y, y âˆˆ a â†’ x' âˆˆ y)) by comp.def [âˆ€y, y âˆˆ a â†’ _ âˆˆ y] [â‹ƒa];

    assume x âˆˆ â‹‚a then âˆ€y, y âˆˆ a â†’ x âˆˆ y logically;

    assume âˆ€y, y âˆˆ a â†’ x âˆˆ y then x âˆˆ â‹‚a as
        follows x âˆˆ â‹ƒa as
            obtain y st y âˆˆ a  by nonempty.has_element;
            follows     x âˆˆ y  logically;
            thus        x âˆˆ â‹ƒa by big_union.def;
        ;
        done logically
    ;

    done logically
qed

The big intersection of a set is a subset of every element of the set.

theorem big_inter.sub [a b : term] : (a âˆˆ b)
    |- â‹‚b âŠ† a
proof
    follows b â‰  âˆ…                            by nonempty.has_element;
    follows âˆ€x, x âˆˆ â‹‚b â†” (âˆ€y, y âˆˆ b â†’ x âˆˆ y) by big_inter.def;
    thus    âˆ€x, x âˆˆ â‹‚b â†’              x âˆˆ a  logically;
qed

We do however define the small intersection the same way we defined the big
intersection.

notation inter
    term ::= term " âˆ© " term
end

definition
    a âˆ© b := â‹‚{a, b}
end

Since the pair set is always non-empty, the small intersection is always well
defined.

theorem inter.def [a b : term] :
    |- âˆ€x, x âˆˆ a âˆ© b â†” (x âˆˆ a âˆ§ x âˆˆ b)
proof
    -- we need that the pair set isn't empty.
    follows a âˆˆ {a, b} by pair.def;
    thus    {a, b} â‰  âˆ… by empty.def; 

    -- which allows us to continue the proof using big_inter.def
    suffices âˆ€x, x âˆˆ â‹‚{a, b} â†” (x âˆˆ a âˆ§ x âˆˆ b);
    follows  âˆ€x, x âˆˆ â‹‚{a, b} â†” (âˆ€y, y âˆˆ {a, b} â†’ x âˆˆ y) by big_inter.def;
    follows  âˆ€y, y âˆˆ  {a, b} â†” (y = a âˆ¨ y = b)          by pair.def;
    thus     âˆ€x, x âˆˆ â‹‚{a, b} â†” (x âˆˆ a âˆ§ x âˆˆ b)          logically;
qed

Like the union, the intersection is symmetric and associative. The proofs are
identical to those for union, just replacing every $\lor$ with an $\land$.

theorem inter.symm [a b : term] :
    |- a âˆ© b = b âˆ© a
proof
    follows âˆ€x, x âˆˆ a âˆ© b â†” (x âˆˆ a âˆ§ x âˆˆ b) by inter.def;
    follows âˆ€x, x âˆˆ b âˆ© a â†” (x âˆˆ a âˆ§ x âˆˆ b) by inter.def;
    thus a âˆ© b = b âˆ© a                      by zfc.extensionality;
qed

theorem inter.assoc [a b c : term] :
    |- a âˆ© (b âˆ© c) = (a âˆ© b) âˆ© c
proof
    follows âˆ€x, x âˆˆ a âˆ© (b âˆ© c) â†” (x âˆˆ a âˆ§ (x âˆˆ b âˆ§ x âˆˆ c)) by inter.def;
    follows âˆ€x, x âˆˆ (a âˆ© b) âˆ© c â†” ((x âˆˆ a âˆ§ x âˆˆ b) âˆ§ x âˆˆ c) by inter.def;
    thus a âˆ© (b âˆ© c) = (a âˆ© b) âˆ© c                          by zfc.extensionality;
qed

The intersection of two sets is a subset of both of the original sets.

theorem inter.sub_left [a b : term] :
    |- a âˆ© b âŠ† a
proof
    follows âˆ€x, x âˆˆ a âˆ© b â†” (x âˆˆ a âˆ§ x âˆˆ b) by inter.def;
    thus    âˆ€x, x âˆˆ a âˆ© b â†’  x âˆˆ a          logically;
qed

theorem inter.sub_right [a b : term] :
    |- a âˆ© b âŠ† b
proof
    follows âˆ€x, x âˆˆ a âˆ© b â†” (x âˆˆ a âˆ§ x âˆˆ b) by inter.def;
    thus    âˆ€x, x âˆˆ a âˆ© b â†’          x âˆˆ b  logically;
qed

### The Set Difference

We define the difference between two sets as the set of elements of the first set which are not in the second set.

notation set_difference
    term ::= term " - " term
end

definition
    a - b := {x âˆˆ a | x âˆ‰ b}
end

The theorem follows easily from the definition of the set difference:

theorem set_diff.def [a b : term] :
    |- âˆ€x, x âˆˆ a - b â†” (x âˆˆ a âˆ§ x âˆ‰ b)
proof
    suffices âˆ€x, x âˆˆ {y âˆˆ a | y âˆ‰ b} â†” (x âˆˆ a âˆ§ x âˆ‰ b);
    done by comp.def [_ âˆ‰ b] [a]
qed

The set difference is a subset of the first set. This follows from the fact that
all restricted comprehensions are subsets.

theorem set_diff.sub [a b : term] :
    |- a - b âŠ† a
proof
    suffices {x âˆˆ a | x âˆ‰ b} âŠ† a;
    done by comp.sub [_ âˆ‰ b] [a]
qed

### The Powerset

We will define the powerset as the set of all subsets of a set. 

notation term.with_term
    term ::= @name "(" term ")"
end

definition
    ğ’«(a) := {x | x âŠ† a}
end

The existence of this set is provided by one of the ZFC axioms in the same
manner as before.

theorem powset.def [a : term] :
    |- âˆ€x, x âˆˆ ğ’«(a) â†” x âŠ† a
proof
    suffices âˆ€x, x âˆˆ {y | y âŠ† a} â†” x âŠ† a;
    follows âˆƒb, âˆ€x, x âˆˆ b â†” (âˆ€y, y âˆˆ x â†’ y âˆˆ a) by zfc.powerset;
    thus    âˆƒb, âˆ€x, x âˆˆ b â†” x âŠ† a;
    thus    âˆ€x, x âˆˆ {y | y âŠ† a} â†” x âŠ† a by uncomp.def [_ âŠ† a];
qed

The singletons and pairs of elements from the original set are both examples
of sets in the powerset.

theorem powset.singleton_in [a A : term] : (a âˆˆ A)
    |- {a} âˆˆ ğ’«(A)
proof
    follows {a} âŠ† A by singleton.sub;
    thus {a} âˆˆ ğ’«(A) by powset.def;
qed

theorem powset.pair_in [a b A : term] : (a âˆˆ A) (b âˆˆ A)
    |- {a, b} âˆˆ ğ’«(A)
proof
    follows {a, b} âŠ† A by pair.sub;
    thus {a, b} âˆˆ ğ’«(A) by powset.def;
qed


## Functions

### The Ordered Pair

An ordered pair (a, b) is a set composed of a singleton {a} and a pair {a, b}. We can use ordered pairs to enforce certain structure on sets.
notation ordered_pair
    term ::= "âŸ¨" term ", " term "âŸ©"
end

definition
    âŸ¨a, bâŸ© := {{a}, {a, b}}
end

The proof follows from the pairing axiom and the definition of the ordered pair.

theorem ordered_pair.def [a b : term] :
    |- âˆ€x, x âˆˆ âŸ¨a, bâŸ© â†” (x = {a} âˆ¨ x = {a, b})
proof
    suffices âˆ€x, x âˆˆ {{a}, {a, b}} â†” (x = {a} âˆ¨ x = {a, b});
    follows âˆƒc, âˆ€x, x âˆˆ c â†” (x = {a} âˆ¨ x = {a, b})      by zfc.pairing;
    thus âˆ€x, x âˆˆ {{a}, {a, b}} â†” (x = {a} âˆ¨ x = {a, b}) by uncomp.def [_ = {a} âˆ¨ _ = {a, b}];
qed

Next, we define a function which gives us the first element of an ordered pair. We define this function somewhat broadly, but it allows for an easy proof.

definition
    Ï€â‚(a) := â‹ƒâ‹‚a
end

The proof follows from the definition of the ordered pair and many of the intersection properties we've shown.

theorem ordered_pair_first.def [a b : term] :
    |- Ï€â‚(âŸ¨a, bâŸ©) = a
proof
    follows âˆ€x, x âˆˆ â‹‚{{a}, {a, b}} â†” (x âˆˆ {a} âˆ§ x âˆˆ {a, b}) by inter.def [{a}] [{a, b}];
    hence âˆ€x, x âˆˆ {a} â†” x = a by singleton.def [a];
    hence âˆ€x, x âˆˆ {a, b} â†” (x = a âˆ¨ x = b) by pair.def [a] [b];
    thus âˆ€x, x âˆˆ â‹ƒâ‹‚{{a}, {a, b}} â†” x âˆˆ a by big_union.def;
    follows âˆ€x, x âˆˆ Ï€â‚(âŸ¨a, bâŸ©) â†” x âˆˆ a;
    thus Ï€â‚(âŸ¨a, bâŸ©) = a by zfc.extensionality;
qed

### The Cartesian Product

The Cartesian product of two sets is the set of all ordered pairs formed from
the elements of those sets. A double powerset is sufficient to make a superset
of the Cartesian product from which we can then restrict to get the required
set.

notation product
    term ::= term " Ã— " term
end

definition
    A Ã— B := {x âˆˆ ğ’«(ğ’«(A âˆª B)) | âˆƒa, a âˆˆ A âˆ§ (âˆƒb, b âˆˆ B âˆ§ x = âŸ¨a, bâŸ©)}
end

The difficult task is to prove that this gives us every possible ordered pair.

theorem cart_prod.def [A B : term] :
    |- âˆ€x, x âˆˆ A Ã— B â†” âˆƒa, a âˆˆ A âˆ§ (âˆƒb, b âˆˆ B âˆ§ x = âŸ¨a, bâŸ©)
proof
    arbitrary x;

    follows âˆ€x, (x âˆˆ A Ã— B â†” (x âˆˆ ğ’«(ğ’«(A âˆª B)) âˆ§ (âˆƒa, a âˆˆ A âˆ§ (âˆƒb, (b âˆˆ B âˆ§ x = âŸ¨a, bâŸ©)))))
        by comp.def [âˆƒa, a âˆˆ A âˆ§ (âˆƒb, b âˆˆ B âˆ§ _ = âŸ¨a, bâŸ©)] [ğ’«(ğ’«(A âˆª B))];

    -- the forward direction is pretty simple. it just comes directly from the
    -- definition of restricted comprehension.

    assume x âˆˆ A Ã— B then âˆƒa, a âˆˆ A âˆ§ (âˆƒb, b âˆˆ B âˆ§ x = âŸ¨a, bâŸ©) as
        thus âˆƒa, a âˆˆ A âˆ§ (âˆƒb, b âˆˆ B âˆ§ x = âŸ¨a, bâŸ©) logically;
    ;

    -- the other direction is harder. it follows quickly that x satisfies the
    -- comprehension condition, but it is a little more work to show it is in
    -- the double powerset.
    assume âˆƒa, a âˆˆ A âˆ§ (âˆƒb, b âˆˆ B âˆ§ x = âŸ¨a, bâŸ©) then x âˆˆ A Ã— B as
        obtain a st a âˆˆ A âˆ§ (âˆƒb, b âˆˆ B âˆ§ x = âŸ¨a, bâŸ©);
        obtain b st b âˆˆ B âˆ§ x = âŸ¨a, bâŸ© logically;
        follows x = âŸ¨a, bâŸ© logically;
        thus x = {{a}, {a, b}};

        -- we already have that x is a pair so we just need to prove it is in the powerset
        suffices x âˆˆ ğ’«(ğ’«(A âˆª B)) âˆ§ (âˆƒa', a' âˆˆ A âˆ§ (âˆƒb', (b' âˆˆ B âˆ§ x = âŸ¨a', b'âŸ©))) logically;
        suffices x âˆˆ ğ’«(ğ’«(A âˆª B)) logically;

        follows a âˆˆ A âˆª B âˆ§ b âˆˆ A âˆª B    by union.def;
        thus  {a}          âˆˆ   ğ’«(A âˆª B)  by powset.singleton_in;
        thus       {a, b}  âˆˆ   ğ’«(A âˆª B)  by powset.pair_in;
        thus {{a}, {a, b}} âˆˆ ğ’«(ğ’«(A âˆª B)) by powset.pair_in;
        thus             x âˆˆ ğ’«(ğ’«(A âˆª B)) logically;
    ;

    done logically
qed