Set theory is almost the simplest possible first order logical system. It
contains no formal terms and only a single binary predicate symbol: $\in$. 

syntax membership
    sentence ::= term " ∈ " term
end

The intended reading of $x \in y$ is that $y$ is a set of which $x$ is an element.
In our version of set theory, *all* objects are sets. Despite this simplicity,
we can encode essentially all of mathematics using set theory. We will find
ways to encode objects not traditionally thought of as sets using sets.

We have an intuitive notion of what a set is, but of course, we will need to
provide axioms to make this understanding rigorous.


## Axioms

The set of axioms we will be using for our set theory is called the 
Zermelo-Fraenkel axioms with Choice, abbreviated ZFC. There are other systems of
axioms we could use, but ZFC is a commonly accepted set.

You may be hoping that $\in$ will come with two axioms, an introduction and an
elimination rule. Sadly this is not the case.

We do get an elimination rule. It says that two sets are equal if they contain
exactly the same elements. This is traditionally known as extensionality. 

axiom zfc.extensionality :
    |- ∀a, ∀b, (∀x, x ∈ a ↔ x ∈ b) → a = b
end

We will be presenting the axioms as unschematized statements in first-order
logic without using the iota operator. This is done to make clear the 
distinction between the axioms for which this can be done, and those for which 
it can't. We will state more natural forms of these axioms as theorems later.

Intuitively, a set is supposed to be a collection of all the objects with a
certain property. Therefore, we might naturally expect to have an introduction
rule similar to the following:

```
 axiom zfc.comprehension [p(_:term) : sentence] :
    |- ∃x, ∀y, (y ∈ x ↔ p(y))
 end
```

However, such an axiom would be inconsistent. In particular, we would run into
Russell's paradox: the axiom allows us to construct the set $X = \{x ~|~ x \not\in x\}$
which consists of all sets which do not contain themselves. Then we ask if
$X \in X$. If it is then it should not be and if it isn't then it should be. We
have a contradiction. 

This leads us to the conclusion that not all properties can define sets. The
remainder of the axioms of ZFC essentially define restricted forms of our
idealized comprehension axiom which are believed not to lead to a contradiction.
This will leave us with various operations which we can use to define our sets.
In the end, almost all the sets we care about will be definable with these
operations and so we will be able to act much as if we did have unrestricted
comprehension.

The empty set axiom asserts the existence of a set with no elements.

axiom zfc.empty_set :
    |- ∃x, ∀y, ¬y ∈ x 
end

For any two sets we can form the set containing exactly those two sets.

axiom zfc.pairing :
    |- ∀a, ∀b, ∃x, ∀y, y ∈ x ↔ (y = a ∨ y = b)
end

For any set we can take the union of all element in the set.

axiom zfc.union :
    |- ∀a, ∃x, ∀y, y ∈ x ↔ (∃z, y ∈ z ∧ z ∈ a)
end

For any set we can form the set of all subsets of the set (the powerset).

axiom zfc.powerset :
    |- ∀a, ∃x, ∀y, y ∈ x ↔ (∀z, z ∈ y → z ∈ a)
end

There is a set containing the empty set with the property that for any $x$ in
the set, the set also contains $x \cup \{x\}$. Such a set is called an inductive
set and must be infinite. Without this axiom we would have no way to prove any
infinite sets exist.

axiom zfc.infinity :
    |- ∃x, (∃y, y ∈ x ∧ ∀z, ¬z ∈ y) 
         ∧ (∀y, (y ∈ x → (∃z, (z ∈ x ∧ (∀w, (w ∈ z ↔ (w ∈ y ∨ w = y)))))))
end

Then we get the two axiom schemas. These are statements about all sentences
which can't be stated using only quantifiers. The first says that for any set
we can take the subset of all elements with a particular property. This is 
quite similar to the rejected comprehension axiom, but this one doesn't lead to
contradictions (as far as we know). This is sometimes also called seperation or
restricted comprehension.

axiom zfc.specification [p(_:term) : sentence] :
    |- ∀a, ∃x, ∀y, y ∈ x ↔ (y ∈ a ∧ p(y))
end

This axiom asserts that the image of any set under a function (implicitly 
defined by $p$) exists. This is surprisingly rarely required.

axiom zfc.replacement [p(_0:term, _1:term) : sentence] :
    |- ∀a, ((∀x, x ∈ a → ∃!y, p(x, y)) → (∃x, ∀y, y ∈ x ↔ (∃z, z ∈ a ∧ p(z, y))))
end

The final axiom has a formal statement that is somewhat difficult to parse. But
the important point is that it guarantees that we do not get an infinite chain
of descending sets $x_0 \ni x_1 \ni x_2 \ni \dots$. In other words, all sets
are nested at a finite depth (despite the fact that some sets contain an 
infinite number of elements). 

axiom zfc.regularity :
    |- ∀a, (∃x, x ∈ a) → (∃y, y ∈ a ∧ ¬∃z, (z ∈ y ∧ z ∈ a))
end

The final axiom is the famed Axiom of Choice. It is the C in ZFC. However it has 
a much longer first order statement and it is generally considered more polite 
to be clear when one is using it. So we will postpone adding it until it becomes 
necessary.


## Set Operations

The fundamental operation over sets is forming the set of all elements with a
certain property. We discussed previously that this set does not always exist,
however the iota operator allows us to define notation for it which will have
the expected properties if it does exist.

notation comprehension
    term ::= "{" x:@binding(term) " | " sentence(x) "}"
end

definition
    {x | p(x)} := ℩y, ∀x, x ∈ y ↔ p(x)
end

We want to prove that if the set $\{x ~|~ p(x)\}$ exists, then the notation we 
have given for it will refer to that step. We need to invoke the iota axiom
from the previous chapter.

theorem uncomp.def [p(_:term) : sentence] : (∃x, ∀y, y ∈ x ↔ p(y))
    |- ∀y, y ∈ {x | p(x)} ↔ p(y) 
proof
    -- this property is essentially the definition of {x | p(x)} so we just
    -- need to extract it using iota.unique. to do this we need that
    -- the set is unique.
    suffices ∃!x, ∀y, y ∈ x ↔ p(y) by iota.unique [∀y, y ∈ _ ↔ p(y)];

    -- we can unwrap the definition of ∃!. this step is by definition.
    suffices (∃x, ∀y, y ∈ x ↔ p(y)) ∧ (∃*x, ∀y, y ∈ x ↔ p(y));

    -- we already have the lhs as a hypothesis.
    suffices ∃*x, ∀y, y ∈ x ↔ p(y) by and.intro [∃x, ∀y, y ∈ x ↔ p(y)] [∃*x, ∀y, y ∈ x ↔ p(y)];

    -- now we unwrap the definition of ∃*.
    suffices ∀a, ∀b, ((∀y, y ∈ a ↔ p(y)) ∧ (∀y, y ∈ b ↔ p(y))) → a = b;

    -- let's extract all the pieces of this definition.
    arbitrary a;
    arbitrary b;
    assume (∀y, y ∈ a ↔ p(y)) ∧ (∀y, y ∈ b ↔ p(y));
    thus ∀y, y ∈ a ↔ p(y) by and.elim_left  [∀y, y ∈ a ↔ p(y)] [∀y, y ∈ b ↔ p(y)];
    thus ∀y, y ∈ b ↔ p(y) by and.elim_right [∀y, y ∈ a ↔ p(y)] [∀y, y ∈ b ↔ p(y)];

    -- now we can prove the equality using extensionality.
    suffices ∀x, x ∈ a ↔ x ∈ b as
        follows ∀a, ∀b, ((∀x, x ∈ a ↔ x ∈ b) → a = b) by zfc.extensionality;
        thus ∀b, ((∀x, x ∈ a ↔ x ∈ b) → a = b) specializing ∀a, ∀b, ((∀x, x ∈ a ↔ x ∈ b) → a = b);
        thus (∀x, x ∈ a ↔ x ∈ b) → a = b       specializing ∀b, ((∀x, x ∈ a ↔ x ∈ b) → a = b);
        thus a = b by modus_ponens [∀x, x ∈ a ↔ x ∈ b] [a = b];
    ;

    arbitrary x;

    -- We can use the transitivity of ↔ to finish the proof.
    follows x ∈ a ↔ p(x) specializing ∀y, y ∈ a ↔ p(y);
    follows x ∈ b ↔ p(x) specializing ∀y, y ∈ b ↔ p(y);
    thus p(x) ↔ x ∈ b  by iff.symm [x ∈ b] [p(x)];
    thus x ∈ a ↔ x ∈ b by iff.trans [x ∈ a] [p(x)] [x ∈ b];
qed

Sorry, was that painful to read? It was painful to write. That proof wasn't
actually very complicated but it was 40 lines long anyway. This is not 
sustainable. Lucky we have something to help. [Vampire](https://vprover.github.io/)
is an _automated theorem prover_. It will find proofs of mathematical facts
automatically. We can make a new tactic that send the current known facts and
goal to Vampire to have it generate a proof. This proof is then translated
for Watson to understand. This is a very complex, but also very powerful tactic
which eliminates the need for tedious manipulations.

tactic tactic.vampire
    tactic ::= @kw"vampire"
end

We have also enhanced our pre-existing tactics with the power of Vampire. For
example, `contradiction` will now use Vampire to search for a contradiction and
`by` will now employ Vampire to prove the goal using the theorem. If we want to 
inform Vampire of a theorem it would find useful we can also use the `recall`
 tactic which will add the named theorem to our list of known facts, making it
useable by Vampire.

tactic tactic.recall
    tactic ::= @kw"recall" thm:@name ";" next:tactic
end

Returning to mathematics, we can use the unrestricted comprehension syntax to 
define our first concrete set, the empty set.

notation empty_set
    term ::= "∅"
end

definition
    ∅ := {x | ⊥}
end

The empty set axiom tells us that this set actually exists.

theorem empty_set.def :
    |- ∀x, ¬x ∈ ∅
proof
    -- expand the definition of ∅
    suffices ∀x, ¬x ∈ {x | ⊥};
    -- existence from the axiom
    follows ∃x, ∀y, ¬y ∈ x        by zfc.empty_set;
    thus    ∃x, ∀y, (y ∈ x ↔ ⊥)   as vampire;     
    -- and then set comprehension is always unique
    thus    ∀y, (y ∈ {x | ⊥} ↔ ⊥) by uncomp.def [⊥];
    thus    ∀y, ¬y ∈ {x | ⊥}      as vampire;
qed

We can develop the pair set in an essentially identical way.

notation pair
    term ::= "{" term ", " term "}"
end

definition 
    {a, b} := {x | x = a ∨ x = b}
end

This time it is the pairing axiom that tells us that this set exists.

theorem pair.def [a b : term] :
    |- ∀x, x ∈ {a, b} ↔ (x = a ∨ x = b)
proof
    suffices ∀x, x ∈ {y | y = a ∨ y = b} ↔ (x = a ∨ x = b);
    
    follows ∃c, ∀x, x ∈ c ↔ (x = a ∨ x = b) as recall zfc.pairing; vampire;
    thus    ∀x, x ∈ {y | y = a ∨ y = b} ↔ (x = a ∨ x = b) by uncomp.def [_ = a ∨ _ = b];
qed

We can define the singleton set as the pair of the same element twice. We could
define it as simply $\{a\} = \{x ~|~ x = a\}$ but how would we prove this set
exists? We would have to appeal to the pairing axiom anyway.

notation singleton
    term ::= "{" term "}"
end

definition
    {a} := {a, a}
end

theorem singleton.def [a : term] :
    |- ∀x, x ∈ {a} ↔ x = a
proof
    -- expand the definition of {a}
    suffices ∀x, x ∈ {a, a} ↔ x = a;
    -- and then Vampire easily finishes the job from the definition of {a, a}
    recall pair.def; vampire
qed

We can return to defining new sets with the union of a set.

notation big_union
    term ::= "⋃" term
end

definition
    ⋃a := {x | ∃y, x ∈ y ∧ y ∈ a}
end

Once more the existence of this set is guaranteed by the union axiom of ZFC.

theorem big_union.def [a : term] :
    |- ∀x, x ∈ ⋃a ↔ (∃y, x ∈ y ∧ y ∈ a)
proof
    suffices ∀x, x ∈ {x | ∃y, x ∈ y ∧ y ∈ a} ↔ (∃y, x ∈ y ∧ y ∈ a);
    recall zfc.union;
    follows ∃x, ∀y, y ∈ x ↔ (∃z, y ∈ z ∧ z ∈ a) as vampire;
    follows ∀x, x ∈ {x | ∃y, x ∈ y ∧ y ∈ a} ↔ (∃y, x ∈ y ∧ y ∈ a) by uncomp.def [∃y, _ ∈ y ∧ y ∈ a];
qed
