Set theory is almost the simplest possible first order logical system. It
contains no formal terms and only a single binary predicate symbol: $\in$. 

syntax in
    sentence (500) ::= term " âˆˆ " term
end

notation not_in
    sentence (500) ::= term " âˆ‰ " term
end

@[reducible]
definition
    a âˆ‰ b := Â¬a âˆˆ b
end

The intended reading of $x \in y$ is that $y$ is a set of which $x$ is an element.
In our version of set theory, *all* objects are sets. Despite this simplicity,
we can encode essentially all of mathematics using set theory. We will find
ways to encode objects not traditionally thought of as sets using sets.

We have an intuitive notion of what a set is, but of course, we will need to
provide axioms to make this understanding rigorous.


## Axioms

The set of axioms we will be using for our set theory is called the 
Zermelo-Fraenkel axioms with Choice, abbreviated ZFC. There are other systems of
axioms we could use, but ZFC is a commonly accepted set.

You may be hoping that $\in$ will come with two axioms, an introduction and an
elimination rule. Sadly this is not the case.

We do get an elimination rule. It says that two sets are equal if they contain
exactly the same elements. This is traditionally known as extensionality. 

axiom zfc.extensionality :
    |- âˆ€a, âˆ€b, (âˆ€x, x âˆˆ a â†” x âˆˆ b) â†’ a = b
end

We will be presenting the axioms as unschematized statements in first-order
logic without using the iota operator. This is done to make clear the 
distinction between the axioms for which this can be done, and those for which 
it can't. We will state more natural forms of these axioms as theorems later.

Intuitively, a set is supposed to be a collection of all the objects with a
certain property. Therefore, we might naturally expect to have an introduction
rule similar to the following:

```
 axiom zfc.comprehension [p(_:term) : sentence] :
    |- âˆƒx, âˆ€y, (y âˆˆ x â†” p(y))
 end
```

However, such an axiom would be inconsistent. In particular, we would run into
Russell's paradox: the axiom allows us to construct the set $X = \{x ~|~ x \not\in x\}$
which consists of all sets which do not contain themselves. Then we ask if
$X \in X$. If it is then it should not be and if it isn't then it should be. We
have a contradiction. 

This leads us to the conclusion that not all properties can define sets. The
remainder of the axioms of ZFC essentially define restricted forms of our
idealized comprehension axiom which are believed not to lead to a contradiction.
This will leave us with various operations which we can use to define our sets.
In the end, almost all the sets we care about will be definable with these
operations and so we will be able to act much as if we did have unrestricted
comprehension.

The empty set axiom asserts the existence of a set with no elements.

axiom zfc.empty_set :
    |- âˆƒx, âˆ€y, y âˆ‰ x 
end

For any two sets we can form the set containing exactly those two sets.

axiom zfc.pairing :
    |- âˆ€a, âˆ€b, âˆƒx, âˆ€y, y âˆˆ x â†” y = a âˆ¨ y = b
end

For any set we can take the union of all elements in the set.

axiom zfc.union :
    |- âˆ€a, âˆƒx, âˆ€y, y âˆˆ x â†” (âˆƒz, y âˆˆ z âˆ§ z âˆˆ a)
end

For any set we can form the set of all subsets of the set (the powerset).

axiom zfc.powerset :
    |- âˆ€a, âˆƒx, âˆ€y, y âˆˆ x â†” (âˆ€z, z âˆˆ y â†’ z âˆˆ a)
end

There is a set containing the empty set with the property that for any $x$ in
the set, the set also contains $x \cup \{x\}$. Such a set is called an inductive
set and must be infinite. Without this axiom we would have no way to prove any
infinite sets exist.

axiom zfc.infinity :
    |- âˆƒx, (âˆƒy, y âˆˆ x âˆ§ âˆ€z, z âˆ‰ y) 
         âˆ§ (âˆ€y, y âˆˆ x â†’ âˆƒz, z âˆˆ x âˆ§ (âˆ€w, w âˆˆ z â†” w âˆˆ y âˆ¨ w = y))
end

Then we get the two axiom schemas. These are statements about all sentences
which can't be stated using only quantifiers. The first says that for any set
we can take the subset of all elements with a particular property. This is 
quite similar to the rejected comprehension axiom, but this one doesn't lead to
contradictions (as far as we know). This is sometimes also called separation or
restricted comprehension.

axiom zfc.specification [p(_) : sentence(term)] :
    |- âˆ€a, âˆƒx, âˆ€y, y âˆˆ x â†” y âˆˆ a âˆ§ p(y)
end

This axiom asserts that the image of any set under a function (implicitly 
defined by $p$) exists. This is surprisingly rarely required.

axiom zfc.replacement [p(_0, _1) : sentence(term, term)] :
    |- âˆ€a, (âˆ€x, x âˆˆ a â†’ âˆƒ!y, p(x, y)) â†’ (âˆƒx, âˆ€y, y âˆˆ x â†” (âˆƒz, z âˆˆ a âˆ§ p(z, y)))
end

The final axiom has a formal statement that is somewhat difficult to parse. But
the important point is that it guarantees that we do not get an infinite chain
of descending sets $x_0 \ni x_1 \ni x_2 \ni \dots$. In other words, all sets
are nested at a finite depth (despite the fact that some sets contain an 
infinite number of elements). 

axiom zfc.regularity :
    |- âˆ€a, (âˆƒx, x âˆˆ a) â†’ (âˆƒy, y âˆˆ a âˆ§ Â¬âˆƒz, (z âˆˆ y âˆ§ z âˆˆ a))
end

The final axiom is the famed Axiom of Choice. It is the C in ZFC. However it has 
a much longer first order statement and it is generally considered more polite 
to be clear when one is using it. So we will postpone adding it until it becomes 
necessary.


## Set Operations

The fundamental operation over sets is forming the set of all elements with a
certain property. We discussed previously that this set does not always exist,
however the iota operator allows us to define notation for it which will have
the expected properties if it does exist.

notation comprehension
    term ::= "{" x:@binding(term) " | " sentence(x) "}"
end

definition
    {x | p(x)} := â„©y, âˆ€x, x âˆˆ y â†” p(x)
end

We want to prove that if the set $\{x ~|~ p(x)\}$ exists, then the notation we 
have given for it will refer to that set. We need to invoke the iota axiom
from the previous chapter.

theorem uncomp.def [p(_) : sentence(term)] : (âˆƒx, âˆ€y, y âˆˆ x â†” p(y))
    |- âˆ€y, y âˆˆ {x | p(x)} â†” p(y) 
proof
    -- this property is essentially the definition of {x | p(x)} so we just
    -- need to extract it using iota.unique. to do this we need that
    -- the set is unique.
    suffices âˆƒ!x, âˆ€y, y âˆˆ x â†” p(y) by iota.unique [âˆ€y, y âˆˆ _ â†” p(y)];

    -- we can unwrap the definition of âˆƒ!. this step is by definition.
    suffices (âˆƒx, âˆ€y, y âˆˆ x â†” p(y)) âˆ§ (âˆƒ*x, âˆ€y, y âˆˆ x â†” p(y));

    -- we already have the lhs as a hypothesis.
    suffices âˆƒ*x, âˆ€y, y âˆˆ x â†” p(y) by and.intro [âˆƒx, âˆ€y, y âˆˆ x â†” p(y)] [âˆƒ*x, âˆ€y, y âˆˆ x â†” p(y)];

    -- now we unwrap the definition of âˆƒ*.
    suffices âˆ€a, âˆ€b, (âˆ€y, y âˆˆ a â†” p(y)) âˆ§ (âˆ€y, y âˆˆ b â†” p(y)) â†’ a = b;

    -- let's extract all the pieces of this definition.
    arbitrary a;
    arbitrary b;
    assume (âˆ€y, y âˆˆ a â†” p(y)) âˆ§ (âˆ€y, y âˆˆ b â†” p(y));
    thus âˆ€y, y âˆˆ a â†” p(y) by and.elim_left  [âˆ€y, y âˆˆ a â†” p(y)] [âˆ€y, y âˆˆ b â†” p(y)];
    thus âˆ€y, y âˆˆ b â†” p(y) by and.elim_right [âˆ€y, y âˆˆ a â†” p(y)] [âˆ€y, y âˆˆ b â†” p(y)];

    -- now we can prove the equality using extensionality.
    suffices âˆ€x, x âˆˆ a â†” x âˆˆ b as
        follows âˆ€a, âˆ€b, (âˆ€x, x âˆˆ a â†” x âˆˆ b) â†’ a = b by zfc.extensionality;
        thus âˆ€b, (âˆ€x, x âˆˆ a â†” x âˆˆ b) â†’ a = b specializing âˆ€a, âˆ€b, (âˆ€x, x âˆˆ a â†” x âˆˆ b) â†’ a = b;
        thus (âˆ€x, x âˆˆ a â†” x âˆˆ b) â†’ a = b     specializing âˆ€b, (âˆ€x, x âˆˆ a â†” x âˆˆ b) â†’ a = b;
        thus a = b by modus_ponens [âˆ€x, x âˆˆ a â†” x âˆˆ b] [a = b];
    ;

    arbitrary x;

    -- We can use the transitivity of â†” to finish the proof.
    follows x âˆˆ a â†” p(x) specializing âˆ€y, y âˆˆ a â†” p(y);
    follows x âˆˆ b â†” p(x) specializing âˆ€y, y âˆˆ b â†” p(y);
    thus p(x) â†” x âˆˆ b  by iff.symm [x âˆˆ b] [p(x)];
    thus x âˆˆ a â†” x âˆˆ b by iff.trans [x âˆˆ a] [p(x)] [x âˆˆ b];
qed

Sorry, was that painful to read? It was painful to write. That proof wasn't
actually very complicated but it was 40 lines long anyway. This is not 
sustainable. Lucky we have something to help. [Vampire](https://vprover.github.io/)
is an _automated theorem prover_. It will find proofs of mathematical facts
automatically. We can make a new tactic that sends the current known facts and
goal to Vampire to have it generate a proof. This proof is then translated
for Watson to understand. This is a very complex but also very powerful tactic
which eliminates the need for tedious manipulations.

grammar_category sentence_list

tactic sentence_list.one sentence_list ::= sentence:@fragment(sentence) end
tactic sentence_list.many sentence_list ::= sentence:@fragment(sentence) @kw"and" rest:sentence_list end

grammar_category givens

tactic givens.none givens ::= end
tactic givens.some givens ::= @kw"given" sentences:sentence_list end

tactic justification.logically
    justification ::= @kw"logically"
end

tactic justification.given
    justification ::= @kw"given" givens:sentence_list
end

-- TODO: explain
tactic tactic.done
    tactic ::= @kw"done" just:justification
end

grammar_category theorem_list

tactic theorem_list.one theorem_list ::= thm:@name end
tactic theorem_list.many theorem_list ::= thm:@name "," rest:theorem_list end

tactic justification.by.vampire
    -- bind weaker than the original by so we don't override it.
    justification (600) ::= @kw"by" thms:theorem_list givens:givens
end


We have also enhanced our pre-existing tactics with the power of Vampire. For
example, `contradiction` will now use Vampire to search for a contradiction and
`by` will now employ Vampire to prove the goal using the theorem. If we want to 
inform Vampire of a theorem that it would find useful we can also use the `recall`
 tactic which will add the named theorem to our list of known facts, making it
usable by Vampire.

tactic tactic.recall
    tactic ::= @kw"recall" thm:@name ";" next:tactic
end

### The Subset Relation

The other fundamental relationship between sets, besides equality, is the
subset relation.

notation subset
    sentence (500) ::= term " âŠ† " term
end

definition
    a âŠ† b := âˆ€x, x âˆˆ a â†’ x âˆˆ b
end

theorem sub.def [a b : term] :
    |- a âŠ† b â†” âˆ€x, x âˆˆ a â†’ x âˆˆ b
proof
    done by iff.refl [a âŠ† b]
qed

The subset relation is both reflexive and transitive.

theorem sub.refl [a : term] :
    |- a âŠ† a
proof
    suffices âˆ€x, x âˆˆ a â†’ x âˆˆ a by sub.def;
    done logically
qed

theorem sub.trans [a b c : term] : (a âŠ† b) (b âŠ† c)
    |- a âŠ† c
proof
    follows âˆ€x, x âˆˆ a â†’ x âˆˆ b by sub.def given a âŠ† b;
    follows âˆ€x, x âˆˆ b â†’ x âˆˆ c by sub.def given b âŠ† c;
    thus    âˆ€x, x âˆˆ a â†’ x âˆˆ c logically;
    done by sub.def
qed

We also have that if two sets are subsets of each other then they are equal. 
In fact, this is just a restatement of the extensionality axiom.

theorem sub.sub_eq [a b : term] : (a âŠ† b) (b âŠ† a)
    |- a = b
proof
    follows âˆ€x, x âˆˆ a â†’ x âˆˆ b by sub.def given a âŠ† b;
    follows âˆ€x, x âˆˆ b â†’ x âˆˆ a by sub.def given b âŠ† a;
    thus âˆ€x, x âˆˆ a â†” x âˆˆ b logically;
    thus a = b by zfc.extensionality;
qed

We can also have the notion of a strict subset.

notation strict_subset
    sentence (500) ::= term " âŠ‚ " term
end

@[reducible]
definition
    a âŠ‚ b := a âŠ† b âˆ§ a â‰  b
end

theorem ssub.def [a b : term] :
    |- a âŠ‚ b â†” (a âŠ† b âˆ§ a â‰  b)
proof
    done by iff.refl [a âŠ‚ b]
qed

### Bounded Quantifiers

When defining the subset relation we wrote $\forall x, x \in a \to x \in b$. The
$x \in a \to$ component makes the quantifier only meaningful for elements of the
set $a$. This is a very common pattern so we will define shorthand notation for
it. 

notation forall.bounded
    sentence (000) ::= "âˆ€" x:@binding(term) " âˆˆ " term ", " sentence(x)
end

@[reducible]
definition
    âˆ€x âˆˆ X, p(x) := âˆ€x, x âˆˆ X â†’ p(x)
end

Note that for the existential quantifier we use $\land$ instead of $\to$
because we are looking for an element that is both in the set and satisfies
the property.

notation exists.bounded
    sentence (000) ::= "âˆƒ" x:@binding(term) " âˆˆ " term ", " sentence(x)
end

@[reducible]
definition
    âˆƒx âˆˆ X, p(x) := âˆƒx, x âˆˆ X âˆ§ p(x)
end

### The Empty Set

Returning to mathematics, we can use the unrestricted comprehension syntax to 
define our first concrete set, the empty set.

notation empty_set
    term ::= "âˆ…"
end

definition
    âˆ… := {x | âŠ¥}
end

The empty set axiom tells us that this set actually exists.

theorem empty.def :
    |- âˆ€x, x âˆ‰ âˆ…
proof
    -- expand the definition of âˆ…
    suffices âˆ€x, x âˆ‰ {x | âŠ¥};
    -- existence from the axiom
    follows âˆƒx, âˆ€y,  y âˆ‰ x        by zfc.empty_set;
    thus    âˆƒx, âˆ€y, (y âˆˆ x â†” âŠ¥)   logically;     
    -- and then set comprehension is always unique
    thus    âˆ€y, (y âˆˆ {x | âŠ¥} â†” âŠ¥) by uncomp.def [âŠ¥];
    thus    âˆ€y,  y âˆ‰ {x | âŠ¥}      logically;
qed

We can also characterize a non-empty set as one containing an element.

theorem nonempty.has_element [a : term] :
    |- a â‰  âˆ… â†” âˆƒx, x âˆˆ a
proof
    follows âˆ€x, x âˆ‰ âˆ…          by empty.def;
    follows a = âˆ… â†”  âˆ€x, x âˆ‰ a by zfc.extensionality; 
    thus    a â‰  âˆ… â†” Â¬âˆ€x, x âˆ‰ a logically;
    thus    a â‰  âˆ… â†”  âˆƒx, x âˆˆ a logically;
qed

The empty set is a subset of any set.

theorem empty.is_sub [a : term] :
    |- âˆ… âŠ† a
proof
    follows âˆ€x, x âˆ‰ âˆ…         by empty.def;
    thus    âˆ€x, x âˆˆ âˆ… â†’ x âˆˆ a logically;
qed

Every subset of the empty set is the empty set.

theorem empty.sub_is_empty [a : term] : (a âŠ† âˆ…)
    |- a = âˆ…
proof
    follows âˆ€x, x âˆˆ a â†’ x âˆˆ âˆ… by sub.def;
    follows âˆ€x,         x âˆ‰ âˆ… by empty.def;
    thus   Â¬âˆƒx, x âˆˆ a         logically;
    thus    a = âˆ…             by zfc.extensionality;
qed

### The Unordered Pair

We can develop the pair set in an essentially identical way.

notation pair
    term ::= "{" term ", " term "}"
end

definition 
    {a, b} := {x | x = a âˆ¨ x = b}
end

This time it is the pairing axiom that tells us that this set exists.

theorem pair.def [a b : term] :
    |- âˆ€x, x âˆˆ {a, b} â†” (x = a âˆ¨ x = b)
proof
    suffices âˆ€x, x âˆˆ {y | y = a âˆ¨ y = b} â†” (x = a âˆ¨ x = b);
    follows âˆƒc, âˆ€x, x âˆˆ c â†” (x = a âˆ¨ x = b)               by zfc.pairing;
    thus    âˆ€x, x âˆˆ {y | y = a âˆ¨ y = b} â†” (x = a âˆ¨ x = b) by uncomp.def [_ = a âˆ¨ _ = b];
qed

The unordered pair is unordered. That is, it is symmetric.

theorem pair.symm [a b : term] :
    |- {a, b} = {b, a}
proof
    thus âˆ€x, x âˆˆ {a, b} â†” x âˆˆ {b, a} by pair.def;
    thus {a, b} = {b, a}             by zfc.extensionality;
qed

The unordered pair being a subset is equivalent to both elements of the pair
being members of the set.

theorem pair.sub [a b A : term] :
    |- (a âˆˆ A âˆ§ b âˆˆ A) â†” {a, b} âŠ† A
proof
    done by sub.def, pair.def
qed

### The Singleton Set

We can define the singleton set as the pair of the same element twice. We could
define it as simply $\{a\} = \{x ~|~ x = a\}$ but how would we prove this set
exists? We would have to appeal to the pairing axiom anyway.

notation singleton
    term ::= "{" term "}"
end

definition
    {a} := {a, a}
end

theorem singleton.def [a : term] :
    |- âˆ€x, x âˆˆ {a} â†” x = a
proof
    -- expand the definition of {a}
    suffices âˆ€x, x âˆˆ {a, a} â†” x = a;
    -- and then Vampire easily finishes the job from the definition of {a, a}
    thus âˆ€x, x âˆˆ {a, a} â†” x = a by pair.def;
qed

An element being in a set is equivalent to the singleton set being a subset.

theorem singleton.sub [a A : term] :
    |- a âˆˆ A â†” {a} âŠ† A
proof
    follows a âˆˆ A â†’ (âˆ€x, x âˆˆ {a} â†’ x âˆˆ A) by singleton.def;
    follows (âˆ€x, x âˆˆ {a} â†’ x âˆˆ A) â†’ a âˆˆ A by singleton.def;
    done by sub.def
qed

### Restricted Comprehension

In contrast to unrestricted comprehensions, which are not always sets, a
comprehension which is limited to be a subset of another set always exists. This
is guaranteed by the specification axiom.

notation restricted_comprehension
    term ::= "{" x:@binding(term) " âˆˆ " term " | " sentence(x) "}"
end

definition
    {x âˆˆ X | p(x)} := {x | x âˆˆ X âˆ§ p(x)}
end

This proof follows from the specification axiom.

theorem comp.def [p(_) : sentence(term)] [X : term] :
    |- âˆ€y, y âˆˆ {x âˆˆ X | p(x)} â†” (y âˆˆ X âˆ§ p(y))
proof
    suffices âˆ€y, y âˆˆ {x | x âˆˆ X âˆ§ p(x)} â†” (y âˆˆ X âˆ§ p(y));
    hence âˆ€a, âˆƒx, âˆ€y, y âˆˆ x â†” (y âˆˆ a âˆ§ p(y)) by zfc.specification [p(_)];
    follows âˆƒx, âˆ€y, y âˆˆ x â†” (y âˆˆ X âˆ§ p(y))   logically;
    thus âˆ€y, y âˆˆ {x | x âˆˆ X âˆ§ p(x)} â†” (y âˆˆ X âˆ§ p(y)) by uncomp.def [_ âˆˆ X âˆ§ p(_)];
qed

It easily follows from this definition that a restricted comprehension is
always a subset of the original set.

theorem comp.sub [p(_) : sentence(term)] [X : term] :
    |- {x âˆˆ X | p(x)} âŠ† X
proof
    follows âˆ€y, y âˆˆ {x âˆˆ X | p(x)} â†” (y âˆˆ X âˆ§ p(y)) by comp.def [p(_)] [X];
    thus    âˆ€y, y âˆˆ {x âˆˆ X | p(x)} â†’  y âˆˆ X         logically;
qed

Because `comp.def` is a second order theorem, that is it is schematized over
all predicates $p$, Vampire cannot reason with it automatically. This is why we
had to manually provide the template instantiations when we invoked it.
Restricted comprehension comes up so frequently and invoking second order
theorems is so tedious that we are just going to hard code this theorem so that
it is automatically given to Vampire any time a comprehension appears in the 
local context. 

### Unions

We can return to defining new sets with the union of a set.

notation big_union
    term (000) ::= "â‹ƒ" term
end

definition
    â‹ƒa := {x | âˆƒy, x âˆˆ y âˆ§ y âˆˆ a}
end

Once more the existence of this set is guaranteed by the union axiom of ZFC.

theorem big_union.def [a : term] :
    |- âˆ€x, x âˆˆ â‹ƒa â†” (âˆƒy, x âˆˆ y âˆ§ y âˆˆ a)
proof
    suffices âˆ€x, x âˆˆ {x | âˆƒy, x âˆˆ y âˆ§ y âˆˆ a} â†” (âˆƒy, x âˆˆ y âˆ§ y âˆˆ a);
    follows âˆƒx, âˆ€y, y âˆˆ x â†” (âˆƒz, y âˆˆ z âˆ§ z âˆˆ a) by zfc.union;
    follows âˆ€x, x âˆˆ {x | âˆƒy, x âˆˆ y âˆ§ y âˆˆ a} â†” (âˆƒy, x âˆˆ y âˆ§ y âˆˆ a) by uncomp.def [âˆƒy, _ âˆˆ y âˆ§ y âˆˆ a];
qed

Any element of a set is a subset of the union of that set.

theorem big_union.super [a b : term] : (a âˆˆ b)
    |- a âŠ† â‹ƒb
proof
    follows âˆ€x, (âˆƒy, x âˆˆ y âˆ§ y âˆˆ b) â†” x âˆˆ â‹ƒb by big_union.def;
    thus    âˆ€x,      x âˆˆ a          â†’ x âˆˆ â‹ƒb logically;
qed

Next we show that the Union of a singleton is the element of the singleton.

theorem big_union.singleton [a : term] :
    |- â‹ƒ{a} = a
proof
    follows âˆ€x, x âˆˆ {a} â†” x = a by singleton.def;
    hence âˆ€x, x âˆˆ â‹ƒ{a} â†” (âˆƒy, x âˆˆ y âˆ§ y âˆˆ {a}) by big_union.def [{a}];
    thus âˆ€x, x âˆˆ â‹ƒ{a} â†” (âˆƒy, x âˆˆ y âˆ§ y = a) logically;
    follows âˆ€x, x âˆˆ â‹ƒ{a} â†” (âˆƒy, x âˆˆ a) logically;
    follows âˆ€x, x âˆˆ â‹ƒ{a} â†” x âˆˆ a logically;
    done by zfc.extensionality
qed
We can define the regular union using the pair and the big union. Once again,
although we could define this directly using unrestricted comprehension, it is
easier to do it this way to avoid repeated proofs of existence.

notation union
    term (650) ::= term " âˆª " term
end

definition
    a âˆª b := â‹ƒ{a, b}
end

The definition of the union can be easily proved from the definitions of the
big union and the pair.

theorem union.def [a b : term] :
    |- âˆ€x, x âˆˆ a âˆª b â†” (x âˆˆ a âˆ¨ x âˆˆ b)
proof
    suffices âˆ€x, x âˆˆ â‹ƒ{a, b} â†” (x âˆˆ a âˆ¨ x âˆˆ b);
    follows  âˆ€x, x âˆˆ â‹ƒ{a, b} â†” âˆƒy, x âˆˆ y âˆ§ y âˆˆ {a, b} by big_union.def;
    follows  âˆ€y, y âˆˆ  {a, b} â†” (y = a âˆ¨ y = b)        by pair.def;
    done logically
qed

The union operator is also symmetric. This follows either from the fact that
the unordered pair is symmetric, or just the symmetry of or itself.

theorem union.symm [a b : term] :
    |- a âˆª b = b âˆª a
proof
    follows âˆ€x, x âˆˆ a âˆª b â†” (x âˆˆ a âˆ¨ x âˆˆ b) by union.def;
    follows âˆ€x, x âˆˆ b âˆª a â†” (x âˆˆ a âˆ¨ x âˆˆ b) by union.def;
    thus a âˆª b = b âˆª a                      by zfc.extensionality;
qed

The union is also associative. This follows from the associativity of or.

theorem union.assoc [a b c : term] :
    |- a âˆª (b âˆª c) = (a âˆª b) âˆª c
proof
    follows âˆ€x, x âˆˆ a âˆª (b âˆª c) â†” (x âˆˆ a âˆ¨ (x âˆˆ b âˆ¨ x âˆˆ c)) by union.def;
    follows âˆ€x, x âˆˆ (a âˆª b) âˆª c â†” ((x âˆˆ a âˆ¨ x âˆˆ b) âˆ¨ x âˆˆ c) by union.def;
    thus a âˆª (b âˆª c) = (a âˆª b) âˆª c                          by zfc.extensionality;
qed

Either set in the union is a subset of the union as a whole. These facts are
really just simplifications of the defining fact.

theorem union.left_sub [a b : term] :
    |- a âŠ† a âˆª b
proof
    follows âˆ€x, (x âˆˆ a âˆ¨ x âˆˆ b) â†” x âˆˆ a âˆª b by union.def;
    thus    âˆ€x,  x âˆˆ a          â†’ x âˆˆ a âˆª b logically;
qed

theorem union.right_sub [a b : term] :
    |- b âŠ† a âˆª b
proof
    follows âˆ€x, (x âˆˆ a âˆ¨ x âˆˆ b) â†” x âˆˆ a âˆª b by union.def;
    thus    âˆ€x,          x âˆˆ b  â†’ x âˆˆ a âˆª b logically;
qed

### Intersections

Instead of defining the big intersection with an unrestricted comprehension as
we did for the big union, we will define it as a subset of the union. This
makes it easier to prove existence.

notation big_inter
    term (000) ::= "â‹‚" term
end

definition
    â‹‚a := {x âˆˆ â‹ƒa | âˆ€y, y âˆˆ a â†’ x âˆˆ y}
end

This definition implies that the intersection of the empty set is the empty set.
However, based on the defining property of the intersection, the intersection of
the empty set should be the proper class of all sets, which isn't a set. So we
restrict the definition theorem to only applying to non-empty sets.

theorem big_inter.def [a : term] : (a â‰  âˆ…)
    |- âˆ€x, x âˆˆ â‹‚a â†” (âˆ€y, y âˆˆ a â†’ x âˆˆ y)
proof
    arbitrary x;
    suffices x âˆˆ {z âˆˆ â‹ƒa | âˆ€y, y âˆˆ a â†’ z âˆˆ y} â†” (âˆ€y, y âˆˆ a â†’ x âˆˆ y);

    assume x âˆˆ {z âˆˆ â‹ƒa | âˆ€y, y âˆˆ a â†’ z âˆˆ y} then âˆ€y, y âˆˆ a â†’ x âˆˆ y logically;

    assume âˆ€y, y âˆˆ a â†’ x âˆˆ y then x âˆˆ {z âˆˆ â‹ƒa | âˆ€y, y âˆˆ a â†’ z âˆˆ y} as
        follows x âˆˆ â‹ƒa as
            obtain y st y âˆˆ a  by nonempty.has_element;
            follows     x âˆˆ y  logically;
            thus        x âˆˆ â‹ƒa by big_union.def;
        ;
        done logically
    ;

    done logically
qed

The big intersection of a set is a subset of every element of the set.

theorem big_inter.sub [a b : term] : (a âˆˆ b)
    |- â‹‚b âŠ† a
proof
    follows b â‰  âˆ…                            by nonempty.has_element;
    follows âˆ€x, x âˆˆ â‹‚b â†” (âˆ€y, y âˆˆ b â†’ x âˆˆ y) by big_inter.def;
    thus    âˆ€x, x âˆˆ â‹‚b â†’              x âˆˆ a  logically;
qed

We do however define the small intersection the same way we defined the big
intersection.

notation inter
    term (700) ::= term " âˆ© " term
end

definition
    a âˆ© b := â‹‚{a, b}
end

Since the pair set is always non-empty, the small intersection is always well
defined.

theorem inter.def [a b : term] :
    |- âˆ€x, x âˆˆ a âˆ© b â†” (x âˆˆ a âˆ§ x âˆˆ b)
proof
    -- we need that the pair set isn't empty.
    follows a âˆˆ {a, b} by pair.def;
    thus    {a, b} â‰  âˆ… by empty.def; 

    -- which allows us to continue the proof using big_inter.def
    suffices âˆ€x, x âˆˆ â‹‚{a, b} â†” (x âˆˆ a âˆ§ x âˆˆ b);
    follows  âˆ€x, x âˆˆ â‹‚{a, b} â†” (âˆ€y, y âˆˆ {a, b} â†’ x âˆˆ y) by big_inter.def;
    follows  âˆ€y, y âˆˆ  {a, b} â†” (y = a âˆ¨ y = b)          by pair.def;
    thus     âˆ€x, x âˆˆ â‹‚{a, b} â†” (x âˆˆ a âˆ§ x âˆˆ b)          logically;
qed

Like the union, the intersection is symmetric and associative. The proofs are
identical to those for union, just replacing every $\lor$ with an $\land$.

theorem inter.symm [a b : term] :
    |- a âˆ© b = b âˆ© a
proof
    follows âˆ€x, x âˆˆ a âˆ© b â†” (x âˆˆ a âˆ§ x âˆˆ b) by inter.def;
    follows âˆ€x, x âˆˆ b âˆ© a â†” (x âˆˆ a âˆ§ x âˆˆ b) by inter.def;
    thus a âˆ© b = b âˆ© a                      by zfc.extensionality;
qed

theorem inter.assoc [a b c : term] :
    |- a âˆ© (b âˆ© c) = (a âˆ© b) âˆ© c
proof
    follows âˆ€x, x âˆˆ a âˆ© (b âˆ© c) â†” (x âˆˆ a âˆ§ (x âˆˆ b âˆ§ x âˆˆ c)) by inter.def;
    follows âˆ€x, x âˆˆ (a âˆ© b) âˆ© c â†” ((x âˆˆ a âˆ§ x âˆˆ b) âˆ§ x âˆˆ c) by inter.def;
    thus a âˆ© (b âˆ© c) = (a âˆ© b) âˆ© c                          by zfc.extensionality;
qed

The intersection of two sets is a subset of both of the original sets.

theorem inter.sub_left [a b : term] :
    |- a âˆ© b âŠ† a
proof
    follows âˆ€x, x âˆˆ a âˆ© b â†” (x âˆˆ a âˆ§ x âˆˆ b) by inter.def;
    thus    âˆ€x, x âˆˆ a âˆ© b â†’  x âˆˆ a          logically;
qed

theorem inter.sub_right [a b : term] :
    |- a âˆ© b âŠ† b
proof
    follows âˆ€x, x âˆˆ a âˆ© b â†” (x âˆˆ a âˆ§ x âˆˆ b) by inter.def;
    thus    âˆ€x, x âˆˆ a âˆ© b â†’          x âˆˆ b  logically;
qed

### The Set Difference

We define the difference between two sets as the set of elements of the first set which are not in the second set.

notation set_difference
    term (700) ::= term " - " term
end

definition
    a - b := {x âˆˆ a | x âˆ‰ b}
end

The theorem follows easily from the definition of the set difference:

theorem set_diff.def [a b : term] :
    |- âˆ€x, x âˆˆ a - b â†” (x âˆˆ a âˆ§ x âˆ‰ b)
proof
    suffices âˆ€x, x âˆˆ {y âˆˆ a | y âˆ‰ b} â†” (x âˆˆ a âˆ§ x âˆ‰ b);
    done logically
qed

The set difference is a subset of the first set. This follows from the fact that
all restricted comprehensions are subsets.

theorem set_diff.sub [a b : term] :
    |- a - b âŠ† a
proof
    suffices {x âˆˆ a | x âˆ‰ b} âŠ† a;
    done by comp.sub [_ âˆ‰ b] [a]
qed

We can also characterize a non-empty difference.

theorem set_diff.non_empty [a b : term] : (b âŠ† a)
    |- a - b â‰  âˆ… â†” a â‰  b
proof
    assume a - b â‰  âˆ… then a â‰  b as
        obtain x st x âˆˆ a - b by nonempty.has_element;
        thus x âˆˆ a âˆ§ x âˆ‰ b    by set_diff.def;
        thus a â‰  b            by zfc.extensionality;
    ;

    assume a â‰  b then a - b â‰  âˆ… as
        obtain x st (x âˆˆ a âˆ§ x âˆ‰ b) âˆ¨ (x âˆˆ b âˆ§ x âˆ‰ a) by zfc.extensionality;
        follows Â¬(x âˆˆ b âˆ§ x âˆ‰ a) by sub.def;
        thus      x âˆˆ a âˆ§ x âˆ‰ b  logically;
        thus      x âˆˆ a - b      by set_diff.def;
        thus      a - b â‰  âˆ…      by nonempty.has_element;
    ;

    done logically
qed

### The Powerset

We will define the powerset as the set of all subsets of a set. 

notation term.with_term
    term ::= @name "(" term ")"
end

definition
    ğ’«(a) := {x | x âŠ† a}
end

The existence of this set is provided by one of the ZFC axioms in the same
manner as before.

theorem powset.def [a : term] :
    |- âˆ€x, x âˆˆ ğ’«(a) â†” x âŠ† a
proof
    suffices âˆ€x, x âˆˆ {y | y âŠ† a} â†” x âŠ† a;
    follows âˆƒb, âˆ€x, x âˆˆ b â†” (âˆ€y, y âˆˆ x â†’ y âˆˆ a) by zfc.powerset;
    thus    âˆƒb, âˆ€x, x âˆˆ b â†” x âŠ† a;
    thus    âˆ€x, x âˆˆ {y | y âŠ† a} â†” x âŠ† a by uncomp.def [_ âŠ† a];
qed

The singletons and pairs of elements from the original set are both examples
of sets in the powerset.

theorem powset.singleton_in [a A : term] : (a âˆˆ A)
    |- {a} âˆˆ ğ’«(A)
proof
    follows {a} âŠ† A by singleton.sub;
    thus {a} âˆˆ ğ’«(A) by powset.def;
qed

theorem powset.pair_in [a b A : term] : (a âˆˆ A) (b âˆˆ A)
    |- {a, b} âˆˆ ğ’«(A)
proof
    follows {a, b} âŠ† A by pair.sub;
    thus {a, b} âˆˆ ğ’«(A) by powset.def;
qed


## Functions

### The Ordered Pair

An ordered pair (a, b) is a set composed of a singleton {a} and a pair {a, b}. We can use ordered pairs to enforce certain structure on sets.
notation ordered_pair
    term ::= "âŸ¨" term ", " term "âŸ©"
end

definition
    âŸ¨a, bâŸ© := {{a}, {a, b}}
end

The proof follows from the pairing axiom and the definition of the ordered pair.

theorem ordered_pair.def [a b : term] :
    |- âˆ€x, x âˆˆ âŸ¨a, bâŸ© â†” (x = {a} âˆ¨ x = {a, b})
proof
    suffices âˆ€x, x âˆˆ {{a}, {a, b}} â†” (x = {a} âˆ¨ x = {a, b});
    follows âˆƒc, âˆ€x, x âˆˆ c â†” (x = {a} âˆ¨ x = {a, b})      by zfc.pairing;
    thus âˆ€x, x âˆˆ {{a}, {a, b}} â†” (x = {a} âˆ¨ x = {a, b}) by uncomp.def [_ = {a} âˆ¨ _ = {a, b}];
qed

Lets prove some basic properties of ordered pairs

theorem ordered_pair.union [a b : term] :
    |- â‹ƒâŸ¨a, bâŸ© = {a, b}
proof
    suffices â‹ƒ{{a}, {a, b}} = {a, b};
    thus âˆ€x, x âˆˆ {a, b} â†” (x = a âˆ¨ x = b) by pair.def;
    thus âˆ€x, x âˆˆ â‹ƒ{{a}, {a, b}} â†” (x âˆˆ {a} âˆ¨ x âˆˆ {a, b}) by union.def [{a}] [{a, b}];
    hence âˆ€x, (x = a âˆ¨ (x = a âˆ¨ x = b)) â†” (x = a âˆ¨ x = b) logically;
    follows âˆ€x, (x âˆˆ {a} âˆ¨ x âˆˆ {a, b}) â†” (x = a âˆ¨ (x = a âˆ¨ x = b)) by singleton.def, pair.def;
    done by zfc.extensionality
qed

theorem ordered_pair.inter [a b : term] :
    |- â‹‚âŸ¨a, bâŸ© = {a}
proof
    suffices â‹‚{{a}, {a, b}} = {a};
    thus âˆ€x, x âˆˆ {a} â†” x = a by singleton.def;
    thus âˆ€x, x âˆˆ {a, b} â†” (x = a âˆ¨ x = b) by pair.def;
    thus âˆ€x, x âˆˆ â‹‚{{a}, {a, b}} â†” (x âˆˆ {a} âˆ§ x âˆˆ {a, b}) by inter.def [{a}] [{a, b}];
    hence âˆ€x, (x = a âˆ§ (x = a âˆ¨ x = b)) â†” x = a logically;
    thus âˆ€x, x âˆˆ â‹‚{{a}, {a, b}} â†” x âˆˆ {a} by singleton.def;
    follows â‹‚{{a}, {a, b}} = {a} by zfc.extensionality;
qed

Next, we define a function which gives us the first element of an ordered pair. We define this function somewhat broadly, but it allows for an easy proof.

definition
    Ï€â‚(a) := â‹ƒâ‹‚a
end

The proof follows from the definition of the ordered pair and many of the intersection properties we've shown.

theorem ordered_pair_first.def [a b : term] :
    |- Ï€â‚(âŸ¨a, bâŸ©) = a
proof
    hence â‹‚âŸ¨a, bâŸ© = {a} by ordered_pair.inter;
    thus â‹ƒ{a} = a by big_union.singleton;
    hence â‹ƒâ‹‚âŸ¨a, bâŸ© = a logically;
qed

Naturally, we now define the second element of an ordered pair.

definition
    Ï€â‚‚(a) := â‹ƒ{x âˆˆ â‹ƒa | â‹ƒa â‰  â‹‚a â†’ x âˆ‰ â‹‚a}
end

This proof follows simply from the definition of the ordered pair and the properties of unions and intersections.

theorem ordered_pair_second.def [a b : term] :
    |- Ï€â‚‚(âŸ¨a, bâŸ©) = b
proof
    -- suffices â‹ƒ{x âˆˆ â‹ƒ{{a}, {a, b}} | â‹ƒ{{a}, {a, b}} â‰  â‹‚{{a}, {a, b}} â†’ x âˆ‰ â‹‚{{a}, {a, b}}} = b;
    -- thus âˆ€x, x âˆˆ â‹ƒ{{a}, {a, b}} â†” (x âˆˆ {a} âˆ¨ x âˆˆ {a, b}) by union.def [{a}] [{a, b}];
    -- follows âˆ€x, x âˆˆ â‹‚{{a}, {a, b}} â†” (x âˆˆ {a} âˆ§ x âˆˆ {a, b}) by inter.def [{a}] [{a, b}];
    -- follows âˆ€x, (x âˆˆ {a} âˆ§ x âˆˆ {a, b}) â†” (x = a âˆ§ x âˆˆ {a, b}) by singleton.def;
    -- follows âˆ€x, (x = a âˆ§ x âˆˆ {a, b}) â†” (x = a âˆ§ (x = a âˆ¨ x = b)) by pair.def;
    -- hence âˆ€x, x âˆˆ â‹‚{{a}, {a, b}} â†” x = a by ordered_pair.inter;
    -- thus âˆ€x, x = a â†” x âˆˆ {a} by singleton.def;
    -- follows â‹‚{{a}, {a, b}} = {a} by zfc.extensionality;
    -- hence â‹ƒâŸ¨a, bâŸ© = {a, b} by ordered_pair.union;
    -- hence â‹ƒ{x âˆˆ {a, b} | {a, b} â‰  {a} â†’ x âˆ‰ {a}} = â‹ƒ{x âˆˆ â‹ƒ{{a}, {a, b}} | â‹ƒ{{a}, {a, b}} â‰  â‹‚{{a}, {a, b}} â†’ x âˆ‰ â‹‚{{a}, {a, b}}} logically;
    -- thus âˆ€x, x âˆˆ {a, b} â†” (x = a âˆ¨ x = b) by pair.def;
    -- hence âˆ€x, x âˆˆ {a} â†” x = a by singleton.def;
    -- follows {a, b} â‰  {a} â†” a â‰  b logically;
    -- hence âˆ€x, ((x = a âˆ¨ x = b) âˆ§ (a â‰  b â†’ x âˆ‰ {a})) â†” (x = b) logically;
    -- thus âˆ€x, x âˆˆ {x âˆˆ {a, b} | {a, b} â‰  {a} â†’ x âˆ‰ {a}} â†” x = b by zfc.extensionality;
    -- hence âˆ€x, x = b â†” x âˆˆ {b} by singleton.def;
    -- follows âˆ€x, x âˆˆ {x âˆˆ {a, b} | {a, b} â‰  {a} â†’ x âˆ‰ {a}} â†” x âˆˆ {b} logically; 
    -- follows {x âˆˆ {a, b} | {a, b} â‰  {a} â†’ x âˆ‰ {a}} = {b} by zfc.extensionality;
    -- hence â‹ƒ{x âˆˆ {a, b} | {a, b} â‰  {a} â†’ x âˆ‰ {a}} = â‹ƒ{b} logically;
    -- hence â‹ƒ{x âˆˆ â‹ƒ{{a}, {a, b}} | â‹ƒ{{a}, {a, b}} â‰  â‹‚{{a}, {a, b}} â†’ x âˆ‰ â‹‚{{a}, {a, b}}} = â‹ƒ{b} logically;
    -- thus âˆ€x, x âˆˆ â‹ƒ{b} â†” (âˆƒy, x âˆˆ y âˆ§ y âˆˆ {b}) by big_union.def;
    -- hence âˆ€x, (âˆƒy, x âˆˆ y âˆ§ y âˆˆ {b}) â†” x âˆˆ b logically;
    -- follows âˆ€x, x âˆˆ â‹ƒ{b} â†” x âˆˆ b logically;
    -- thus â‹ƒ{b} = b by zfc.extensionality;
    -- done logically
    todo
qed

Finally, we show that two ordered pairs are equal iff their first and second elements are equal.

theorem ordered_pair.eq [a b c d : term] :
    |- âŸ¨a, bâŸ© = âŸ¨c, dâŸ© â†” (a = c âˆ§ b = d)
proof
    hence âŸ¨a, bâŸ© = âŸ¨c, dâŸ© â†’ Ï€â‚(âŸ¨a, bâŸ©) = Ï€â‚(âŸ¨c, dâŸ©) by zfc.extensionality;
    follows Ï€â‚(âŸ¨a, bâŸ©) = Ï€â‚(âŸ¨c, dâŸ©) â†” a = c by ordered_pair_first.def;
    follows âŸ¨a, bâŸ© = âŸ¨c, dâŸ© â†’ Ï€â‚‚(âŸ¨a, bâŸ©) = Ï€â‚‚(âŸ¨c, dâŸ©) by zfc.extensionality;
    follows Ï€â‚‚(âŸ¨a, bâŸ©) = Ï€â‚‚(âŸ¨c, dâŸ©) â†” b = d by ordered_pair_second.def;
    -- suffices âŸ¨a, bâŸ© = âŸ¨c, dâŸ© â†” (a = c âˆ§ b = d);
    hence âŸ¨a, bâŸ© = âŸ¨c, dâŸ© â†’ (a = c âˆ§ b = d) logically;
    hence (a = c âˆ§ b = d) â†’ âŸ¨a, bâŸ© = âŸ¨c, dâŸ© logically;
    done logically
qed

### The Cartesian Product

The Cartesian product of two sets is the set of all ordered pairs formed from
the elements of those sets. A double powerset is sufficient to make a superset
of the Cartesian product from which we can then restrict to get the required
set.

notation product
    term (350) ::= term " Ã— " term
end

definition
    A Ã— B := {x âˆˆ ğ’«(ğ’«(A âˆª B)) | âˆƒa âˆˆ A, âˆƒb âˆˆ B, x = âŸ¨a, bâŸ©}
end

The difficult task is to prove that this gives us every possible ordered pair.

theorem cart_prod.def [A B : term] :
    |- âˆ€x, x âˆˆ A Ã— B â†” âˆƒa âˆˆ A, âˆƒb âˆˆ B, x = âŸ¨a, bâŸ©
proof
    arbitrary x;

    -- remember the definition of A Ã— B. (specifically have Vampire remember it)
    follows A Ã— B = {x âˆˆ ğ’«(ğ’«(A âˆª B)) | âˆƒa âˆˆ A, âˆƒb âˆˆ B, x = âŸ¨a, bâŸ©}
        by eq.refl [A Ã— B];

    -- the forward direction is pretty simple. it just comes directly from the
    -- definition of restricted comprehension.
    assume x âˆˆ A Ã— B then âˆƒa âˆˆ A, âˆƒb âˆˆ B, x = âŸ¨a, bâŸ© logically;

    -- the other direction is harder. it follows quickly that x satisfies the
    -- comprehension condition, but it is a little more work to show it is in
    -- the double powerset.
    assume âˆƒa âˆˆ A, âˆƒb âˆˆ B, x = âŸ¨a, bâŸ© then x âˆˆ A Ã— B as
        obtain a st a âˆˆ A âˆ§ (âˆƒb âˆˆ B, x = âŸ¨a, bâŸ©);
        obtain b st b âˆˆ B âˆ§ x = âŸ¨a, bâŸ© logically;
        follows x = âŸ¨a, bâŸ© logically;
        thus x = {{a}, {a, b}};

        -- we already have that x is a pair so we just need to prove it is in the powerset
        suffices x âˆˆ ğ’«(ğ’«(A âˆª B)) âˆ§ (âˆƒa âˆˆ A, âˆƒb âˆˆ B, x = âŸ¨a, bâŸ©) logically;
        suffices x âˆˆ ğ’«(ğ’«(A âˆª B)) logically;

        follows a âˆˆ A âˆª B âˆ§ b âˆˆ A âˆª B    by union.def given a âˆˆ A and b âˆˆ B;
        thus  {a}          âˆˆ   ğ’«(A âˆª B)  by powset.singleton_in;
        thus       {a, b}  âˆˆ   ğ’«(A âˆª B)  by powset.pair_in;
        thus {{a}, {a, b}} âˆˆ ğ’«(ğ’«(A âˆª B)) by powset.pair_in;
        thus             x âˆˆ ğ’«(ğ’«(A âˆª B)) given x = {{a}, {a, b}};
    ;

    done logically
qed

Next we define our set of binary relations between two sets as the powerset of the Cartesian product of those two sets.

notation term.with_term_term
    term ::= @name "(" term ", " term ")"
end

definition
    Rel(A, B) := ğ’«(A Ã— B)
end

A functional relation is a subset of all binary relations such that the first element of each ordered pair in the relation is unique.

notation functional_relation
    term ::= term " â†’ " term
end

definition
    A â†’ B := {f âˆˆ Rel(A, B) | âˆ€a, a âˆˆ A â†’ (âˆƒ!b, b âˆˆ B âˆ§ âŸ¨a, bâŸ© âˆˆ f)}
end

We define a function mapping as the second element of a unique element of a functional relation.

notation function_application
    term ::= term "(" term ")"
end

definition
    f:term (a) := â„©b, âŸ¨a, bâŸ© âˆˆ f
end

-- Now, we define a set map which contains the entire image of a function on a set.

notation set_map
  term ::= "{" term(x) " | " x:@binding(term) " âˆˆ " term "}"
end

definition
    {f(x) | x âˆˆ A} := {y | âˆƒx, x âˆˆ A âˆ§ y = f(x)}
end

-- The proof follows from (I'll figure this out when I complete the proof)

theorem set_map.def [f : term] [A : term] :
    |- âˆ€y, y âˆˆ {f(x) | x âˆˆ A} â†” (âˆƒx, x âˆˆ A âˆ§ y = f(x))
proof
    suffices âˆ€y, y âˆˆ {f(x) | x âˆˆ A} â†” (âˆƒx, x âˆˆ A âˆ§ y = f(x));
    todo
qed


## The Ordinals

Our first goal upon the completion of our development of set theory will be to
define the natural numbers. In order to prove the existence of the set of
natural numbers we will need at least one infinite set. The existence of such a
set is guaranteed by the axiom of infinity. Specifically, we will use infinity
to prove the existence of the first infinite ordinal $\omega$.

First let's define the successor operation on ordinals.

definition
    succ(n) := n âˆª {n}
end

theorem ordinal.succ.def [n : term] :
    |- succ(n) = n âˆª {n}
proof
    done by eq.refl [succ(n)]
qed


The defining property of $\omega$ is that it is the smallest set which contains
$\emptyset$ and is closed under the successor operation. We will call this closure
property inductivity.

definition
    inductive(Î±) := âˆ… âˆˆ Î± âˆ§ (âˆ€n âˆˆ Î±, succ(n) âˆˆ Î±)
end

theorem inductive.def [Î± : term] :
    |- inductive(Î±) â†” âˆ… âˆˆ Î± âˆ§ (âˆ€n âˆˆ Î±, succ(n) âˆˆ Î±)
proof
    done by iff.refl [inductive(Î±)]
qed

By the smallest set we mean that $\omega$ is a subset of any inductive set. Put
another way, $\omega$ is the intersection of the proper class of all inductive sets. 
However, our theory does not contain proper classes so we cannot use the 
intersection operator developed previously. We can instead define $\omega$ using 
an unrestricted comprehension.

definition
    Ï‰ := {x | âˆ€Î±, inductive(Î±) â†’ x âˆˆ Î±}
end

The ZF axiom of infinity guarantees that at least one inductive set exists,
which is what will let us conclude that $\omega$ is well defined.

lemma inductive.exists :
    |- âˆƒÎ±, inductive(Î±)
proof
    suffices âˆƒÎ±, âˆ… âˆˆ Î± âˆ§ âˆ€n âˆˆ Î±, n âˆª {n} âˆˆ Î±;

    -- the object whose existence is guaranteed by the axiom of infinity is the
    -- Î± that we want.
    obtain x st (âˆƒy, y âˆˆ x âˆ§ âˆ€z, z âˆ‰ y) âˆ§ (âˆ€y âˆˆ x, âˆƒz âˆˆ x, âˆ€w, w âˆˆ z â†” w âˆˆ y âˆ¨ w = y)
        by zfc.infinity;

    -- the âˆƒy, y âˆˆ x âˆ§ âˆ€z, z âˆ‰ y tells us that x contains âˆ…
    follows âˆ… âˆˆ x by empty.def, zfc.extensionality;

    -- now we need to show that x is closed under the successor operation
    follows âˆ€n âˆˆ x, n âˆª {n} âˆˆ x as
        arbitrary n; assume n âˆˆ x;
        obtain z st z âˆˆ x âˆ§ (âˆ€w, w âˆˆ z â†” w âˆˆ n âˆ¨ w = n) logically;
        follows âˆ€w, w âˆˆ n âˆª {n} â†” (w âˆˆ n âˆ¨ w = n) by singleton.def, union.def;
        follows z = n âˆª {n} by zfc.extensionality;
        thus    n âˆª {n} âˆˆ x logically;
    ;

    done logically
qed

From this lemma we can deduce that $\omega$ will be well defined, as it is a
subset of that inductive set.

tactic tactic.let
    tactic ::= @kw"let" name:@name ":=" frag:@fragment(term) ";" next:tactic
end

theorem omega.def :
    |- âˆ€x, x âˆˆ Ï‰ â†” (âˆ€Î±, inductive(Î±) â†’ x âˆˆ Î±)
proof
    -- we have at least one inductive set. since Ï‰ is an infinite intersection
    -- restricting the comprehension doesn't change anything. so Ï‰' = Ï‰.
    obtain Î± st inductive(Î±) by inductive.exists;
    let Ï‰' := {x âˆˆ Î± | âˆ€Î², inductive(Î²) â†’ x âˆˆ Î²};

    -- we prove that Ï‰' has the defining property of Ï‰
    follows âˆ€y, y âˆˆ Ï‰' â†” (âˆ€Î², inductive(Î²) â†’ y âˆˆ Î²) as
        arbitrary y;
        suffices y âˆˆ {x âˆˆ Î± | âˆ€Î², inductive(Î²) â†’ x âˆˆ Î²} â†” (âˆ€Î², inductive(Î²) â†’ y âˆˆ Î²);
        assume y âˆˆ {x âˆˆ Î± | âˆ€Î², inductive(Î²) â†’ x âˆˆ Î²} then âˆ€Î², inductive(Î²) â†’ y âˆˆ Î² logically;
        assume âˆ€Î², inductive(Î²) â†’ y âˆˆ Î² then y âˆˆ {x âˆˆ Î± | âˆ€Î², inductive(Î²) â†’ x âˆˆ Î²} as
            follows y âˆˆ Î± given inductive(Î±);
            follows y âˆˆ Î± âˆ§ (âˆ€Î², inductive(Î²) â†’ y âˆˆ Î²) logically;
            done logically
        ;
        done logically
    ;

    -- Ï‰' proves that the infinite intersection exists, so Ï‰ is well defined
    -- and thus has the desired property.
    thus âˆƒw, âˆ€x, x âˆˆ w â†” (âˆ€Î², inductive(Î²) â†’ x âˆˆ Î²) logically;
    thus âˆ€x, x âˆˆ Ï‰ â†” (âˆ€Î², inductive(Î²) â†’ x âˆˆ Î²) by uncomp.def [âˆ€Î², inductive(Î²) â†’ _ âˆˆ Î²];
qed

corollary omega.sub_inductive [a : term] : (inductive(a))
    |- Ï‰ âŠ† a
proof
    done by omega.def, sub.def
qed

corollary omega.inductive :
    |- inductive(Ï‰)
proof
    follows âˆ€Î±, inductive(Î±) â†’ âˆ… âˆˆ Î± by inductive.def;
    thus                       âˆ… âˆˆ Ï‰ by omega.def;

    follows âˆ€n âˆˆ Ï‰, succ(n) âˆˆ Ï‰ as
        arbitrary n; assume n âˆˆ Ï‰;
        follows âˆ€Î±, inductive(Î±) â†’ n âˆˆ Î± by omega.def;
        follows âˆ€Î±, inductive(Î±) â†’ succ(n) âˆˆ Î± by inductive.def;
        thus succ(n) âˆˆ Ï‰ by omega.def;
    ;

    done by inductive.def
qed

At this point we could prove that induction holds on $\omega$. However, $\omega$
is actually just one element of a larger number system called the ordinals. A
more powerful form of induction holds on these ordinal numbers so we will 
instead define the ordinals and prove _transfinite_ induction.

The intuitive definition of the ordinal numbers is as follows: The empty set is
an ordinal number and any set which contains every previously defined ordinal is
an ordinal number. The problem is that this definition is recursive and we are
attempting to use the ordinals to define recursion. Luckily, the ordinals admit
an alternate definition. We define an ordinal as a transitive set that is well
ordered by $\in$.

A transitive set is one where every element is also a subset.

definition 
    transitive(Î±) := âˆ€x âˆˆ Î±, x âŠ† Î±
end

theorem transitive.def [Î± : term] :
    |- transitive(Î±) â†” âˆ€x âˆˆ Î±, x âŠ† Î±
proof
    done by iff.refl [transitive(Î±)]
qed

A well ordered set is one where every non-empty subset has a least element.

definition
    is_least(Î±, Î²) := Î± âˆˆ Î² âˆ§ (âˆ€Î³ âˆˆ Î², Î³ â‰  Î± â†’ Î± âˆˆ Î³)
end

theorem is_least.def [Î± Î² : term] :
    |- is_least(Î±, Î²) â†” Î± âˆˆ Î² âˆ§ (âˆ€Î³ âˆˆ Î², Î³ â‰  Î± â†’ Î± âˆˆ Î³)
proof
    done by iff.refl [is_least(Î±, Î²)]
qed

definition
    well_ordered(Î±) := âˆ€Î², Î² âŠ† Î± âˆ§ Î² â‰  âˆ… â†’ âˆƒÎ³, is_least(Î³, Î²)
end

theorem well_ordered.def [Î± : term] :
    |- well_ordered(Î±) â†” âˆ€Î², Î² âŠ† Î± âˆ§ Î² â‰  âˆ… â†’ âˆƒÎ³, is_least(Î³, Î²)
proof
    done by iff.refl [well_ordered(Î±)]
qed

The combination of these two properties is what defines an ordinal.

notation postfix_pred
    sentence ::= term " : " @name
end

definition
    Î± : Ord := transitive(Î±) âˆ§ well_ordered(Î±)
end

theorem ordinal.def [Î± : term] :
    |- Î± : Ord â†” transitive(Î±) âˆ§ well_ordered(Î±)
proof
    done by iff.refl [Î± : Ord]
qed

The ordinals are ordered by $\in$ so $\alpha < \beta$ can be thought of as
$\alpha \in \beta$. Any ordinal is the set of every previous ordinal. Thus, it
stands to reason that the first ordinal is $\empty$. The two properties are
vacuous when applied to the empty set.

theorem ordinal.empty.is :
    |- âˆ… : Ord
proof
    follows transitive(âˆ…) as
        suffices âˆ€x âˆˆ âˆ…, x âŠ† âˆ… by transitive.def;
        follows âˆ€x, x âˆ‰ âˆ… by empty.def;
        done logically
    ;

    follows well_ordered(âˆ…) as
        suffices âˆ€Î², Î² âŠ† âˆ… âˆ§ Î² â‰  âˆ… â†’ âˆƒÎ³, is_least(Î³, Î²) by well_ordered.def;
        follows  âˆ€Î², Î² âŠ† âˆ… â†’ Î² = âˆ… by empty.sub_is_empty;
        done logically
    ;

    thus âˆ… : Ord by ordinal.def given transitive(âˆ…) and well_ordered(âˆ…);
qed

The empty set is the zero of the ordinal numbers. We can get the next ordinal
from any previous ordinal number by applying the successor operation.

theorem ordinal.succ.is [Î± : term] : (Î± : Ord)
    |- succ(Î±) : Ord
proof
    follows succ(Î±) = Î± âˆª {Î±} by ordinal.succ.def;
    
    follows transitive(succ(Î±)) as
        suffices âˆ€x âˆˆ succ(Î±), x âŠ† succ(Î±) by transitive.def;
        arbitrary x; assume x âˆˆ succ(Î±);

        -- x is either from Î± or is Î±.
        follows x âˆˆ Î± âˆ¨ x = Î± by union.def, singleton.def given succ(Î±) = Î± âˆª {Î±};

        -- if it is Î± then it is in succ(Î±) by definition.
        assume x = Î± then x âŠ† succ(Î±) by union.left_sub given succ(Î±) = Î± âˆª {Î±};
        -- if it is an element of Î± then the fact that Î± is transitive helps us.
        assume x âˆˆ Î± then x âŠ† succ(Î±) as
            follows transitive(Î±) by ordinal.def given Î± : Ord;
            thus x âŠ† Î± by transitive.def;
            follows Î± âŠ† succ(Î±) by union.left_sub;
            thus x âŠ† succ(Î±) by sub.trans;
        ;

        done given x âˆˆ Î± âˆ¨ x = Î±
    ;

    follows well_ordered(succ(Î±)) as
        suffices âˆ€Î², Î² âŠ† succ(Î±) âˆ§ Î² â‰  âˆ… â†’ âˆƒÎ³, is_least(Î³, Î²) by well_ordered.def;
        arbitrary Î²; assume Î² âŠ† succ(Î±) âˆ§ Î² â‰  âˆ…;

        -- there are two cases. either Î² = {Î±} in which case Î± is the least
        -- element or Î² âˆ© Î± â‰  âˆ… in which case we can use the well orderedness of
        -- Î± to get a least element from it.
        assume Î² = {Î±} then is_least(Î±, Î²) as
            suffices Î± âˆˆ Î² âˆ§ (âˆ€Î³ âˆˆ Î², Î³ â‰  Î± â†’ Î± âˆˆ Î³);
            follows Î± âˆˆ Î²          by singleton.def given Î² = {Î±};
            follows Â¬âˆƒÎ³ âˆˆ Î², Î³ â‰  Î± by singleton.def;
            done logically
        ;

        assume Î² â‰  {Î±} then âˆƒÎ³, is_least(Î³, Î²) as
            -- consider only the subset of Î² in Î±
            let Î²' := Î² âˆ© Î±;
            follows Î²' âŠ† Î± âˆ§ Î²' âŠ† Î² by inter.sub_right, inter.sub_left;
            follows Î²' â‰  âˆ… as todo;
            -- we get the minimal element of this subset by the well ordering of Î±
            follows well_ordered(Î±) by ordinal.def given Î± : Ord;
            obtain Î³ st is_least(Î³, Î²') by well_ordered.def;
            thus Î³ âˆˆ Î²' âˆ§ (âˆ€Î´ âˆˆ Î²', Î´ â‰  Î³ â†’ Î³ âˆˆ Î´) by is_least.def;
            -- we want that this is still the least element of Î²
            suffices is_least(Î³, Î²) logically;
            suffices Î³ âˆˆ Î² âˆ§ (âˆ€Î´ âˆˆ Î², Î´ â‰  Î³ â†’ Î³ âˆˆ Î´) by is_least.def;
            -- it's in Î² just because Î²' âŠ† Î²
            follows Î³ âˆˆ Î² by sub.def given Î³ âˆˆ Î²' and Î²' âŠ† Î²;
            follows âˆ€Î´ âˆˆ Î², Î´ â‰  Î³ â†’ Î³ âˆˆ Î´ as
                arbitrary Î´; assume Î´ âˆˆ Î²; assume Î´ â‰  Î³;
                -- any element of Î² is either in Î²' or is Î±
                follows Î´ âˆˆ Î± âˆ¨ Î´ = Î± by union.def, singleton.def, sub.def 
                    given Î´ âˆˆ Î² and Î² âŠ† succ(Î±) and succ(Î±) = Î± âˆª {Î±};
                -- if it is in Î²' the fact that Î³ is least in Î²' suffices
                assume Î´ âˆˆ Î± then Î³ âˆˆ Î´ as
                    follows Î´ âˆˆ Î²' by inter.def given Î´ âˆˆ Î² and Î´ âˆˆ Î±;
                    thus Î³ âˆˆ Î´ given âˆ€Î´ âˆˆ Î², Î´ â‰  Î³ â†’ Î³ âˆˆ Î´;
                ;
                -- if it is Î± then it is easy since every element of Î²' is in Î±
                assume Î´ = Î± then Î³ âˆˆ Î´ by sub.def given Î³ âˆˆ Î²' and Î²' âŠ† Î±;
                done logically
            ;

            done logically
        ;

        done logically
    ;

    thus succ(Î±) : Ord by ordinal.def given transitive(succ(Î±)) and well_ordered(succ(Î±));
qed

With zero and a successor operation we can essentially form each natural number.
We can continue iterating the successor operation indefinitely. However there
are more ordinal numbers than these. In particular, $\omega$ is the set of all
ordinals formed by iterating the successor operation on ordinals, and it is also
an ordinal. 

theorem ordinal.omega.is :
    |- Ï‰ : Ord
proof
    follows transitive(Ï‰) as 
        -- define the set of elements of Ï‰ that are subsets of Ï‰. We will show
        -- that T is inductive, thus T âŠ† Ï‰, thus T = Ï‰, thus Ï‰ is transitive.
        let T := {x âˆˆ Ï‰ | x âŠ† Ï‰};
        follows T âŠ† Ï‰ by comp.sub [_ âŠ† Ï‰] [Ï‰];

        -- T is inductive
        follows âˆ… âˆˆ T as
            follows âˆ… âˆˆ Ï‰ by omega.inductive, inductive.def;
            follows âˆ… âŠ† Ï‰ by empty.is_sub;
            thus âˆ… âˆˆ T logically;
        ;
        follows âˆ€n âˆˆ T, succ(n) âˆˆ T as
            arbitrary n; assume n âˆˆ T;
            thus n âˆˆ Ï‰ âˆ§ n âŠ† Ï‰ logically;
            thus succ(n) âˆˆ Ï‰ by omega.inductive, inductive.def;
            follows n âˆª {n} âŠ† Ï‰ as
                suffices âˆ€x, x âˆˆ n âˆª {n} â†’ x âˆˆ Ï‰;
                arbitrary x; assume x âˆˆ n âˆª {n};
                follows x = n âˆ¨ x âˆˆ n by union.def, singleton.def;
                thus x âˆˆ Ï‰ by sub.def given n âŠ† Ï‰ and n âˆˆ Ï‰;
            ;
            thus    succ(n) âŠ† Ï‰ by ordinal.succ.def;
            thus succ(n) âˆˆ T given succ(n) âˆˆ Ï‰ and succ(n) âŠ† Ï‰;
        ;

        -- T = Ï‰
        thus inductive(T) by inductive.def;
        thus Ï‰ âŠ† T by omega.sub_inductive;
        thus Ï‰ = T by sub.sub_eq;

        -- T is transitive
        thus âˆ€x âˆˆ Ï‰, x âŠ† Ï‰ given Ï‰ = T;
        thus transitive(Ï‰) by transitive.def;
    ;

    todo
qed